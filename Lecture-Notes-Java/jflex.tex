\chapter{The Scanner Generator \textsl{JFlex}}
A  \emph{scanner} is a tool that splits a given string into a list of \emph{tokens}, where a token is
just a group of consecutive characters that belong together logically.  An example will clarify this.  
The input for a \texttt{C}-compiler is a long \textsc{Ascii}-string such that can be interpreted as a
valid \texttt{C} program.  In order to translate this string into machine language, the
\texttt{C}-compiler first groups the different characters into tokens.  In the case of a \texttt{C}
program, the compiler generates the following tokens:
\begin{enumerate}
\item \emph{Keywords}, a.k.a.~reserved words like ``\texttt{if}'', ``\texttt{while}'', or ``\texttt{case}''.
\item \emph{Operator symbols} like ``\texttt{+}'', ``\texttt{+=}'', ``\texttt{<}'', or
      ``\texttt{<=}''. 
\item \emph{Parentheses} like ``\texttt{(}'', ``\texttt{[}'', and ``\texttt{\{}'' and the
      corresponding closing symbols.
\item \emph{Constants}.  The language \texttt{C} distinguishes between three different kinds of constants:
      \begin{enumerate}
      \item Numbers, for example the integer ``\texttt{123}'' or the floating point number ``\texttt{1.23e2}''.
      \item Strings, which are enclosed in double.  For example,
            ``\texttt{\symbol{34}hallo\symbol{34}}'' is a string constant.  Note that the character
            ``\texttt{\symbol{34}}'' is part of the string constant, while the opening and closing
            quotes surrounding the string constant have been used to separate the string constant
            from the surrounding text. 
      \item Single letters that are enclosed in single quotes as in
            ``\texttt{\symbol{39}a\symbol{39}}''.
      \end{enumerate}
\item \emph{Names} that can act as variable names, function names, or type names.
\item \emph{Comments}, which come in two flavors:  \emph{Single line comments} start with the string
      ``\texttt{//}'' and extend to the end of the line, while \emph{multi line comments} start with
      the string ``\texttt{/*}'' and are ended by ``\texttt{*/}''.
\item So called \emph{white space characters}.  For example the blank, tabulators, line breaks, and
      carriage returns are white space symbols.
\end{enumerate}

\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  firstnumber   = 1,
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.8cm,
                  xrightmargin  = 0.8cm,
                ]
    /* Hello World program */
    #include<stdio.h>
    
    int main() {
        printf("Hello World!\n");
        return 1;
    }
\end{Verbatim}
\vspace*{-0.3cm}
\caption{A simple \texttt{C} program.}
\label{fig:hello-world.c}
\end{figure}

To make things more precise, Figure \ref{fig:hello-world.c} contains a \texttt{C} program that
prints the string ``\texttt{Hello World!}'' followed by a newline character.  The scanner would
transform this program into the following list of tokens:
\begin{verbatim}
   [ "/* Hello World program */", "#", "include", "<", "stdio.h", ">",
     "int", "main", "(", ")", "{", "printf", "(", "Hello World!\n", ")", ";"
     "return", "1", ";", "}"
   ]
\end{verbatim}

\textsl{JFlex}\/ \cite{klein:2009} is a so called  \emph{scanner generator}, i.e.~\textsl{JFlex} is
a tool that takes as input the specification of the lexical structure of the tokens and that
generates a scanner from this specification.  Usually, we specify the lexical structure of the
tokens via regular expressions.
You can find \textsl{JFlex} at 
\\[0.2cm]
\hspace*{1.3cm}
\href{http://jflex.de}{\texttt{http://jflex.de}}.
\\[0.2cm]
As \textsl{JFlex} is implemented in  \textsl{Java} it can be used on all platforms that support
\textsl{Java}.    In this lecture, we will use \textsl{Java} version \texttt{1.6.1}.

The next section discusses the structure of a  \textsl{JFlex} input file and we will show how
\textsl{JFlex} is used.  Next, we discuss the syntax of regular expressions as they are used in
\textsl{JFlex}.  We finish the chapter with an example that shows how we can use \textsl{JFlex} to
evaluate the results of an exam.

The scanner generated by \textsl{JFlex}\/ are \textsl{Java} programs.  For the languages \texttt{C}
and \texttt{C++} there exist two similar programs that are called 
\href{http://en.wikipedia.org/wiki/Lex_(software)}{\textsl{Lex}}
\cite{lesk:1975} and \href{http://flex.sourceforge.net}{\textsl{Flex}} \cite{nicol93}, which is
essentially just a faster version of \textsl{Lex}.


\section{Structure of a \textsl{JFlex} Specification}
A  \textsl{JFlex} scanner specification is made up of three parts that are separated by the string
``\texttt{\%\%}''.
This separator string has to be positioned at the start of a line.
\begin{enumerate}
\item The first part is the  \emph{user code}.  This part might contain a
      \texttt{package} declaration and \texttt{import} directives.  Both the package declaration and
      the import directives are copied verbatim into the \textsl{Java} program that is generated by
      \textsl{JFlex}.  Furthermore, the user code may contain the definition of local \textsl{Java}
      classes.  However, the use of local classes is usually not recommended.

      Figure \ref{fig:count.jflex} on pages \pageref{fig:count.jflex} gives an example of the
      \textsl{JFlex} specification of a scanner that has the purpose of recognizing numbers that are
      hidden in a text.  These numbers are then added.
      In this case the user code consists only of the \texttt{package} declaration in line 1.
\item The second part contains options and declarations.  This part sets various options and,
      furthermore, may declare member variables and methods of the generated scanner class.

      In Figure \ref{fig:count.jflex} this part starts in line  4 and ends in line 14.
\item The third part defines the \emph{scanner rules}.  A scanner rule is a pair of a regular
      expression and \textsl{Java} code which is executed if the regular expression is found.

      In Figure \ref{fig:count.jflex} this part starts in line 18 and ends with line 20. 
\end{enumerate}

\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.8cm,
                  xrightmargin  = 0.8cm,
                ]
    package count;
    %%
    
    %class Count
    %standalone
    %unicode
    
    %{
        int mCount = 0;
    %}
    
    %eof{
        System.out.println("Total: " + mCount); 
    %eof}
    
    %%

    0[0-9]+        { /* skip strings like 007 */      }
    0|[1-9][0-9]*  { mCount += new Integer(yytext()); }
    .|\R           { /* skip anything else */         }
\end{Verbatim}
\vspace*{-0.3cm}
\caption{Eine einfache Scanner-Spezifikation f\"ur \textsl{JFlex}}
\label{fig:count.jflex}
\end{figure}

\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.8cm,
                  xrightmargin  = 0.8cm,
                ]
    Here are 33 apples and 5 pears.  Furthermore, here are
    8 bananas and 3 peaches.  James Bond is agent 007.  
    How many pieces of fruit does this text contain?
\end{Verbatim}
\vspace*{-0.3cm}
\caption{Eine Eingabe-Datei f\"ur den in Abbildung \ref{fig:count.jflex} spezifizierten Scanner.}
\label{fig:input.txt}
\end{figure}

We proceed to discuss the \textsl{JFlex} specification shown in Figure \ref{fig:count.jflex}.
The purpose of the scanner that is generated from this \textsl{JFlex} specification is to process 
a string that might contain numbers.  The scanner finds these numbers and adds them up.
For example, a typical string processed by this scanner might be the file shown in 
Figure \ref{fig:input.txt} on page \pageref{fig:input.txt}.  Here our scanner would find the
substrings ``\texttt{33}'', ``\texttt{5}'', ``\texttt{8}'', and ``\texttt{3}'', convert these
strings into numbers, and finally add these numbers.  The scanner would
realize that the string ``\texttt{007}'' is not a number since it starts with a leading zero.

We proceed to discuss the scanner specification shown in \ref{fig:count.jflex} line by line.
\begin{enumerate}
\item Line 1 specifies that the generated scanner is part of the package \texttt{count}.
      If the scanner were a bit more complex we would have to use some \texttt{import} directives
      here as well.  However, as this is example is rather simple, we do not need to import
      any packages.
\item Line 4 specifies that the scanner is part of a class that has the name \texttt{Count}.
\item Line 5 specifies that the scanner is not part of a parser but rather operates on its own.
      Hence,  \textsl{JFlex} will generate a method with the name \texttt{main} as part of the
      class \texttt{Count}.  This method will scan all files that are provided as arguments in the
      command line when the scanner is called.

      A scanner that is equipped with a  $\texttt{main}$ method is called a 
      \emph{stand alone scanner}.  Often, a scanner is used together with a parser.  In that case,
      the \texttt{main} method is not part of the scanner but rather resides in the parser.  We will
      discuss these types of scanners in Chapter \ref{chapter:cup} when we discuss the parser generator 
      \href{http://www2.cs.tum.edu/projects/cup/}{cup}.
\item Line 6 specifies that the generated scanner assumes that strings are encoded using
      \href{https://en.wikipedia.org/wiki/Unicode}{\emph{unicode}}.  This option should always be
      used if the scanner is intended  to process text files.
\item In line 8 to line 10 we declare \texttt{mCount} as a member variable of the scanner that is
      generated.  In order to do this, we use the keywords ``\texttt{\%\{}'' and ``\texttt{\%\}}''.
      Note that these keywords have to be located at the beginning of a line.  Having declared and
      initialized the variable \texttt{mCount} enables us to use this variable in the actions.  This
      is discussed later.

      If the scanner was more complicated, we could also have defined methods inside the keywords
      ``\texttt{\%\{}'' and ``\texttt{\%\}}''.  
      The code for this methods would then be copied verbatim into the generated scanner class.
\item In line 12 to line 14 we specify code that is to be executed once the end of the file to be
      scanned is reached.  This code has to be enclosed using the keywords
      ``\texttt{\%eof\{}'' and ``\texttt{\%eof\}}''.  
      Again, in order to be recognized, these keywords have to be located at the beginning of a line.

      Specifying code that is executed once all input has been read is typically only done in a 
      stand alone scanner.  In this example, the value of the variable \texttt{mCount} is printed,
      since this variable contains the sum of all numbers that have been found.
\item The lines 18 to 20 contain the rules of our scanner.  A scanner rule has the form
      \\[0.2cm]
      \hspace*{1.3cm}
      \textsl{regexp} $\quoted{\{}$ \textsl{action} $\quoted{\}}$
      \\[0.2cm]
      Here, \textsl{regexp} is a regular expression, while \textsl{action} is a fragment of 
      \textsl{Java} code.  This code is executed once text is found that matches the given regular
      expression.
      \begin{enumerate}
      \item In line 18 the regular expression  ``\texttt{0[0-9]+}'' matches any string that starts
            with the digit ``\texttt{0}'', which has to be followed by more digits.
            Here, the regular expression ``\texttt{[0-9]}'' denotes a so called \emph{range}, which
            is the range of all characters from ``\texttt{0}'' to ``\texttt{9}''.
            This range is followed by the postfix operator ``\texttt{+}'', which is similar to the
            Kleene operator ``\texttt{*}''.  The difference between the operator ``\texttt{+}''
            and the operator ``\texttt{*}'' is that the operator ``\texttt{+}'' specifies that at
            least one digit has to occur.  Hence, an expression of the form
            \\[0.2cm]
            \hspace*{1.3cm}
            $r\mathtt{+}$
            \\[0.2cm]
            specifies that $r$ occurs any positive number of times, while
            \\[0.2cm]
            \hspace*{1.3cm}
            $r\mathtt{*}$
            \\[0.2cm]
            specifies that $r$ occurs any number of times, where ``any number of times'' includes
            zero times. We will discuss how \textsl{JFlex} defines regular expressions later in more detail.
 
            In the case of line 18, the action, which is the string enclosed in curly braces, is
            empty because it contains nothing but a comment.  Hence, the sole purpose of line 18 is
            to recognize strings of the form ``007'' and to prevent these strings from being
            processed in line 19.  The point here is that the rules are tried in the order they are
            specified and once a string is scanned with one rule, the string is removed so that it
            is not processed by any of the following rules.

      \item In line 19 the regular expression  ``\texttt{0|[1-9][0-9]*}'' is used to recognize a
            proper natural number.  The corresponding string is returned by the function
            $\texttt{yytext}()$.  This string is then converted into an integer using the
            constructor of the class \texttt{Integer}.  Finally, this integer is added to the
            variable \texttt{mCount} which keeps the running total of all integers found.
      \item In line 20 the regular expression  ``\texttt{.|\symbol{92}R}'' specifies any single character.
            The regular expression ``\texttt{.}'' specifies any character that is different from a
            unicode line break, while ``\texttt{\symbol{92}R}'' specifies any unicode line break.
            Hence,  ``\texttt{\symbol{92}R}'' specifies characters like
            ``\texttt{\symbol{92}n}'' (line feed) or ``\texttt{\symbol{92}r}'' (carriage return),
            but also the unicode characters
            \\[0.2cm]
            \hspace*{1.3cm}
            ``\texttt{\symbol{92}u2028}'',
            ``\texttt{\symbol{92}u2029}'',
            ``\texttt{\symbol{92}u000B}'',
            ``\texttt{\symbol{92}u000C}'' and
            ``\texttt{\symbol{92}u0085}''.
            \\[0.2cm]
            In the regular expression  ``\texttt{.|\symbol{92}R}'' the operator ``\texttt{|}'' denotes the
            choice between two alternatives.  In the previous chapter we had used the  operator ``$+$''
            for this purpose, but the syntax of regular expressions in  \textsl{JFlex} is quite different
            from the syntax we have presented in the previous chapter.  We will discuss the way regular
            expressions are specified in \textsl{JFlex} in the following section.

            In line 20, the action is again empty because it contains just a comment.
            The effect is therefore that all characters that are not matched by the previous rules
            in line 18 or line 19 are just skipped.  This rule is necessary because by default any
            character that is not matched by any of the rules is printed to standard output.
      \end{enumerate}
\end{enumerate}
At this point it is natural to as ask how exactly the rules of a scanner are processed.  The
important question is this: Provided there are two rules such that the regular expressions of these
two rules both match, which rule will be taken?  Here is the answer:
\begin{enumerate}
\item If one of the regular expressions matches a longer prefix of the string than the other rule, the
      rule matching the longer prefix wins and its action is executed.
\item If the both regular expressions match a prefix of the same length, then the rule which appears
      first in the rule section of the scanner specification wins.
\end{enumerate}

In order to generate a scanner from the \textsl{JFlex} specification shown in Figure
\ref{fig:count.jflex} we have to use the  command
\\[0.2cm]
\hspace*{1.3cm}
\texttt{jflex -d count count.jflex}
\\[0.2cm]
which will generate the file \texttt{Count.java}.  The option  ``\texttt{-d}'' specifies that this
file is to be generated in the directory  \texttt{count}.  This is necessary as the scanner contains
the package declaration 
\\[0.2cm]
\hspace*{1.3cm}
\texttt{package count;}.
\\[0.2cm] 
The generated file \texttt{Count.java} is then translated using the following command:
\\[0.2cm]
\hspace*{1.3cm}
\texttt{javac count/Count.java}
\\[0.2cm]
The scanner is then executed using the command:
\\[0.2cm]
\hspace*{1.3cm}
\texttt{java count.Count input.txt}
\\[0.2cm]
Here,  \texttt{input.txt} is the name of the file that is to be scanned.   For the file shown in Figure
\ref{fig:input.txt} we get the result
\\[0.2cm]
\hspace*{1.3cm}
\texttt{Total: 49}.
\\[0.2cm]
In order that we don't have to repeat all of the commands given above it is advisable to use a so
called \href{http://en.wikipedia.org/wiki/Make_(software)}{\textsl{Makefile}}.
Figure \ref{fig:count-makefile} shows the file ``\texttt{Makefile}''.  This files contains rules for
building and running the scanner automatically.


\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  firstnumber   = 1,
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.8cm,
                  xrightmargin  = 0.8cm,
                ]
    run: count/Count.class input.txt
    	java count/Count input.txt
    
    count/Count.class: count/Count.java
    	javac count/Count.java
    
    count/Count.java: count.jflex
	jflex -d count count.jflex
\end{Verbatim}
\vspace*{-0.3cm}
\caption{Ein Makefile zur Erstellung des Scanners.}
\label{fig:count-makefile}
\end{figure}

\begin{enumerate}
\item The first line of the file \texttt{Makefile} defines the \emph{goal} that is to be
      constructed.  In this case, we have named the goal ``\texttt{run}''.  After the 
      goal, the first line lists the \emph{dependencies}.  The dependencies are those
      tasks that need to be completed before the goal can be achieved.
      In this case there are two dependencies and these dependencies are file names: First,
      there is the file \texttt{Count.class}, which is located in the directory \texttt{count}, and
      second there is the file \texttt{input.txt}.  These two files have to be constructed before
      the main goal can be constructed.  Note that the goal and its dependencies have to be
      separated by the character ``\texttt{:}''.

      The second line consists of the command that is executed to reach the goal.  In this case,
      the command executes feeds the file \texttt{input.txt} to the generated scanner.  The
      combination of the first two lines is called a \emph{make rule}.  Every make rule consists of
      an \emph{header line}, which is not indented, and a \emph{body}.  The header specifies the
      goal and its dependencies, while the body contains one or more lines of commands that are
      executed in order to achieve the given goal.  These command lines have to be indented using tab characters.

      \textbf{Warning}:  It is very important that the lines of the body are indented using a tabulator
      character!  If they are indented using blanks instead, the make file would not work.
      This syntactic feature has caused despair to many students, since in the editor,
      a number of blanks can look exactly the same as a tab character.
\item Line 4 specifies how the file \texttt{Count.class} in the directory \texttt{count} is to be
      generated.  In this case, in order to generate the file \texttt{Count.class}, the file
      \texttt{Count.java} is required as a dependency.  Once this dependency is satisfied,
      the file \texttt{Count.java} is constructed using the \textsl{Java} compiler \texttt{javac}.
\item Finally, the rule in line 7 and 8 shows that in order to generate the file
      \texttt{Count.java}, the file \texttt{count.jflex} is required.  Furthermore, is specifies
      that the scanner in file \texttt{Count.java} can be constructed by calling \texttt{jflex}.
\end{enumerate}
Once we have the file \texttt{Makefile}, a single command is sufficient to generate the scanner and
to execute it.  Just typing
\\[0.2cm]
\hspace*{1.3cm}
\texttt{make}
\\[0.2cm] 
in the command line generates the scanner and executes it.  Furthermore, the command \texttt{make}
takes care to perform only the steps that are necessary.  For example, if we had already generated
the scanner in the file \texttt{Count.class}, then \texttt{make} would only execute the command
\\
\hspace*{1.3cm}
\texttt{java count/Count input.txt}
\\[0.2cm]
and not generate the scanner a second time.  However, if \texttt{make} detects that the file
\texttt{count.jflex} has been changed after the file \texttt{count/Count.java} had been generated,
then \texttt{make} knows that the scanner has to be rebuild from scratch.

\remarkEng
While all variants of the \textsl{Unix} operating system are equipped with the command \texttt{make}
from start, the operating system \textsl{Windows} does not provide \texttt{make} by default.
However, on a \textsl{Windows} operating system you can install \texttt{make} from
\\[0.2cm]
\hspace*{1.3cm}
\href{http://sourceforge.net/projects/gnuwin32/files/make/3.81/make-3.81.exe}{\texttt{http://sourceforge.net/projects/gnuwin32/files/make/3.81/make-3.81.exe}}.
\\[0.2cm]
While this is really not necessary for the \textsl{JFlex} examples, having \texttt{make} available
will save you some typing as this lecture proceeds.

\homeworkEng
Install \textsl{JFlex} and make sure that the examples that have been presented in this section of
the lecture notes work with your installation.  If you are working on a \textsl{Windows} operating
system, you should also install \texttt{make}. 

\section{The Syntax of Regular Expressions in \textsl{JFlex}}
In the previous chapter we have defined regular expressions using only a minimal amount of syntax. 
Using as little syntax as possible is beneficial for our upcoming theoretical investigations of
regular expression in the next chapter where we show that regular expressions can be implemented
using finite state machines.  However, for practical applications it is useful to considerably
enrich the syntax of regular expressions that we have seen so far.
For this reason, \textsl{JFlex}\/ provides a number of abbreviations that enable us to denote
complex regular expressions in a more compact form.  The regular expressions of \texttt{JFlex} are
based on the \textsc{Ascii} alphabet.  We have to distinguish between characters, that can be used
as operators, and the remaining characters.   The set of \textsl{OpSyms} of operator symbols is
defined as follows:
\\[0.2cm]
\hspace*{1.3cm}
$\textsl{OpSyms} := \{$ ``\texttt{.}'', 
``\texttt{*}'', 
``\texttt{+}'', 
``\texttt{?}'', 
``\texttt{!}'', 
``\texttt{\symbol{126}}'', 
``\texttt{|}'', 
``\texttt{(}'', 
``\texttt{)}'', 
``\texttt{[}'', 
``\texttt{]}'', 
``\texttt{\{}'', 
``\texttt{\}}'', 
\\[0.2cm]
\hspace*{3.4cm}
``\texttt{<}'', 
``\texttt{>}'',
``\texttt{/}'', 
``\texttt{\symbol{92}}'', 
``\texttt{\symbol{94}}'', 
``\texttt{\symbol{36}}'', 
``\texttt{\symbol{34}}'' $\}$.
\\[0.2cm]
Furthermore,  $\textsl{WsSym}$ denotes the set of all \textsc{Ascii} characters that represent white
space.  Hence this set contains the blank space, the line break, the carriage return, the horizontal
tabulator, and the vertical tabulator.
Using these two sets we can now define the set $\textsl{Regexp}\/$ which is the set of all regular
expressions supported by \textsl{JFlex}.  This set is defined inductively:
\begin{enumerate}
\item $c \in \textsl{Regexp}$ \quad provided $c \in \Sigma_{\textsc{\scriptsize Ascii}}
       \backslash \bigl(\textsl{OpSyms} \cup \textsl{WsSyms}\bigr)$

      All characters $c$  from the \textsc{Ascii} alphabet that are neither operator symbols nor
      white space symbols are regular expressions that match the corresponding character $c$.
\item ``\texttt{.}''$\in \textsl{Regexp}$

      The character ``\texttt{.}'' is a regular expression that matches any character that is different
      from a unicode line break.  The following unicode characters count as line breaks:
      \\[0.2cm]
      \hspace*{1.3cm}
       ``\texttt{\symbol{92}n}'', ``\texttt{\symbol{92}r}'',
       ``\texttt{\symbol{92}u2028}'',
       ``\texttt{\symbol{92}u2029}'',
       ``\texttt{\symbol{92}u000B}'',
       ``\texttt{\symbol{92}u000C}'' und
       ``\texttt{\symbol{92}u0085}''.
\item $\texttt{\symbol{92}}x \in \textsl{Regexp}$ \quad provided $x \in \{ \texttt{a}, \texttt{b}, \texttt{f}, \texttt{n}, \texttt{r}, \texttt{t},
      \texttt{v}, \texttt{R} \}$. 

      Preceding certain characters with a backslash character ``\texttt{\symbol{92}}'' enables us to
      specify control characters.  We have:
      \begin{enumerate}
      \item \texttt{\symbol{92}a} matches the control character \texttt{Ctrl-G} (\emph{alert}).
      \item \texttt{\symbol{92}b} matches the control character \texttt{Ctrl-H} (\emph{backspace}).
      \item \texttt{\symbol{92}f} matches the control character \texttt{Ctrl-L} (\emph{form feed}).
      \item \texttt{\symbol{92}n} matches the control character \texttt{Ctrl-J} (\emph{newline}).
      \item \texttt{\symbol{92}r} matches the control character \texttt{Ctrl-M} (\emph{carriage return}).
      \item \texttt{\symbol{92}t} matches the control character \texttt{Ctrl-I} (\emph{tabulator}).
      \item \texttt{\symbol{92}v} matches the control character \texttt{Ctrl-K} (\emph{vertical tabulator}).
      \item \texttt{\symbol{92}R} matches any unicode line break.
      \end{enumerate}
\item $\texttt{\symbol{92}}abc \in \textsl{Regexp}$ \quad provided $a,b,c \in \{ \texttt{0}, \cdots \texttt{7} \}$ 

      If we use the syntax $\texttt{\symbol{92}}abc$, then $a$, $b$ and $c$ are octal digits and,
      furthermore, $abc$ has to be less than 128 when interpreted as octal number.
      In this case, the regular expression  $\texttt{\symbol{92}}abc$ matches the character that has
      the \textsc{Ascii} code  $abc$.  For example, since the \textsc{Ascii} code of the blank is 32
      in base 10, which is $40_8$ in the octal system, the regular expression
      ``\texttt{\symbol{92}040}'' matches the blank character \mbox{``\texttt{ }''}.

      The biggest number that can be interpreted as an \textsc{Ascii} code is the number 127.
      In octal, this number is written as $177_{8}$.
\item $\texttt{\symbol{92}x}ab \in \textsl{Regexp}$ \quad provided $a,b \in \{ \texttt{0}, \cdots, \texttt{9}, \mathtt{a},\cdots, \mathtt{f}, \mathtt{A},\cdots, \mathtt{F} \}$ 

      If we use the syntax $\texttt{\symbol{92}x}ab$, then $a$ and $b$ have to be hexadecimal
      digits.  Then $\texttt{\symbol{92}x}ab$ matches the character that has the number $ab$ where
      this number is interpreted in the hexadecimal system. 
      For example, the expression ``\texttt{\symbol{92}x5A}'' specifies the character  ``\texttt{Z}''
      because the character ``\texttt{Z}'' has the decimal \textsl{Ascii} code of $90$ and in the
      hexadecimal system this number is written as $\texttt{0x5A}$ since we have $90 = 5 \cdot 16 + 10$.
\item $\texttt{\symbol{92}u}abcd \in \textsl{Regexp}$ \quad provided $a,b,c,d \in \{ \texttt{0}, \cdots, \texttt{9}, \mathtt{a},\cdots, \mathtt{f}, \mathtt{A},\cdots, \mathtt{F} \}$ 

      If we use the syntax $\texttt{\symbol{92}u}abcd$, then $a$, $b$, $c$ and $d$ have to be
      hexadecimal digits.  The regular expression  $\texttt{\symbol{92}u}abcd$ matches the unicode
      character whose position is given by the formula
      \\[0.2cm]
      \hspace*{1.3cm}
      $a \cdot 16^3 + b \cdot 16^2 + c \cdot 16 + d$.
      \\[0.2cm]
      For example, the regular expression \texttt{\symbol{92}u2200} specifies the unicode character ``$\forall$''.
\item $\texttt{\symbol{92}U}abcdef \in \textsl{Regexp}$ \quad provided $a,b,c,d,e,f \in \{ \texttt{0}, \cdots, \texttt{9}, \mathtt{a},\cdots, \mathtt{f}, \mathtt{A},\cdots, \mathtt{F} \}$ 

      In the regular expression $\texttt{\symbol{92}U}abcdef$ the variables  $a$, $b$, $c$, $d$,
      $e$, and $f$ are interpreted as hexadecimal digits.  The expression
      $\texttt{\symbol{92}U}abcdef$ matches the unicode character whose position is given by the
      expression
      \\[0.2cm]
      \hspace*{1.3cm}
      $a \cdot 16^5 + b \cdot 16^4 + c \cdot 16^3 + d \cdot 16^2 + e \cdot 16 + f$.
\item $\texttt{\symbol{92}}o \in \textsl{Regexp}$ \quad provided $o \in \textsl{OpSyms}$ 
      
      In order to match an operator symbol literally, we just have to precede it with a backslash.
      For example, the regular expression ``\texttt{\symbol{92}*}'' matches the string ``\texttt{*}''.
\item $r_1r_2 \in \textsl{Regexp}$ \quad provided $r_1,r_2 \in \textsl{Regexp}$

      The concatenation of two regular expressions is written without the  infix operator
      ``$\cdot$'' in the syntax of \textsl{JFlex}.  Hence, the regular expression $r_1r_2$ matches
      any string $s$ that can be written in the form  $s = uv$ where the prefix $u$ is matched by
      $r_1$, while the suffix $v$ is matched by $r_2$.
\item $r_1\texttt{|}r_2 \in \textsl{Regexp}$ \quad provided $r_1,r_2 \in \textsl{Regexp}$

      The operator ``\texttt{|}'' is the choice operator.  The regular expression $r_1\texttt{|}r_2$
      matches all strings that are matched by $r_1$ as well as all strings matched by  $r_2$.
      In the previous chapter, we had used the  operator ``\texttt{+}'' to achieve the same effect.
      However, the operator ``\texttt{+}'' is interpreted differently in \textsl{JFlex}.
\item $r\texttt{*} \in \textsl{Regexp}$ \quad provided $r \in \textsl{Regexp}$

      The postfix operator ``\texttt{*}'' denotes the Kleene closure.  Hence, the regular expression
      $r\texttt{*}$ matches any string $s$ that can split up into $n$ substrings $t_1$, $\cdots$,
      $t_n$, i.e.~if we have
      \\[0.2cm]
      \hspace*{1.3cm}
      $s = t_1\cdots t_n$
      \\[0.2cm]
      and furthermore $r$ matches every substring $t_i$ for $i=1, \cdots, n$, then $r\texttt{*}$ matches $s$.  Furthermore, $r\texttt{*}$
      matches the empty string.
\item $r\texttt{+} \in \textsl{Regexp}$ \quad provided $r \in \textsl{Regexp}$

      The expression ``$r\texttt{+}$'' is a variant of the Kleene closure.  The only difference
      between  ``$r\texttt{+}$'' and  ``$r\texttt{*}$'' is that  ``$r\texttt{+}$'' does not match
      the empty string.  Algebraically, we have the following relation between these two regular expressions:
      \\[0.2cm]
      \hspace*{1.3cm}
      $r\texttt{+} \doteq rr\mathtt{*}$.
\item $r\texttt{?} \in \textsl{Regexp}$ \quad provided $r \in \textsl{Regexp}$

      The regular expression  ``$r\texttt{?}$'' specifies the same strings specified by $r$, but
      additionally matches the empty string.  Algebraically, we have the following equivalence:
      \\[0.2cm]
      \hspace*{1.3cm}
      $r\texttt{?} \doteq r|\varepsilon$.
      \\[0.2cm]
      Note, however, that \textsl{JFlex} does not support the use of the expression  ``$\varepsilon$'' 
      to denote the empty string.
\item $r\texttt{\{}n\texttt{\}} \in \textsl{Regexp}$ \quad provided $n \in \mathbb{N}$ and $r \in \textsl{Regexp}$

      The regular expression  ``$r\texttt{\{}n\texttt{\}}$'' specifies that $r$ has to occur exactly
      $n$ times.  For example, the regular expression ``\texttt{a\{4\}}'' matches the string
      ``\texttt{aaaa}''. 
\item $r\texttt{\{}m,n \texttt{\}} \in \textsl{Regexp}$ \quad provided $m,n \in \mathbb{N}$ and $m \leq n$ and $r \in \textsl{Regexp}$

      The regular expression  ``$r\texttt{\{}m,n\texttt{\}}$'' specifies that  $r$ has to occur at
      least $m$ times and most occur at most  $n$ times.
      Therefore, the regular expression  ``\texttt{a\{3,5\}}'' matches all of the following strings:
      \\[0.2cm]
      \hspace*{1.3cm}
      ``\texttt{aaa}'', ``\texttt{aaaa}'', and ``\texttt{aaaaa}''.
\item $\texttt{\symbol{94}}r$ \quad provided $r \in \textsl{Regexp}$

      The regular expression  $\texttt{\symbol{94}}r$ specifies that the substring matched by the
      regular expression  $r$ has to occur at the beginning of a line.

      The operator ``\texttt{\symbol{94}}'' must only be used as the outermost operator inside a regular
      expression.  For example
      \\[0.2cm]
      \hspace*{1.3cm}
      $\texttt{\symbol{94}}r_1|r_2$
      \\[0.2cm]
      is not a regular expression, because here ``\texttt{|}'' is the outermost operator that is used.
\item $r\texttt{\symbol{36}}$ \quad provided $r \in \textsl{Regexp}$

      The regular expression $r\texttt{\symbol{36}}$ specifies that the regular expression $r$ has
      to occur at the end of a line.

      The usage of the operator  ``\texttt{\symbol{36}}'' suffers a similar restriction as the usage
      of the operator ``\texttt{\symbol{94}}'':  The operator ``\texttt{\symbol{36}}'' has to be the
      outermost operator of the regular expression.  Hence,
      \\[0.2cm]
      \hspace*{1.3cm}
      $r_1|r_2\texttt{\symbol{36}}$
      \\[0.2cm]
      is not a regular expression because here the operator ``\texttt{|}'' would be the outermost
      operator.
\item $r_1\texttt{/}r_2$ \quad provided $r_1, r_2 \in \textsl{Regexp}$
  
      The regular expression $r_1\texttt{/}r_2$ specifies that the text matched by the regular
      expression  $r_1$ has to be followed by text that matches the regular expression $r_2$.
      However, in contrast to the concatenation $r_1r_2$ the regular expression $r_1/r_2$ matches
      only the string matched by $r_1$.
      Hence, the  operator ``\texttt{/}'' can be seen as posing an additional constraint to the
      regular expression $r_1$.

      The method ``\texttt{yytext()}'', which returns the substring that has been matched, only
      returns the string that has been matched by $r_1$, while the string matched by  $r_2$ remains
      unprocessed. The string matched by $r_2$ is known as \emph{trailing context}.

      The operator ``\texttt{/}'' must always be the outermost operator of the regular expression in
      which it occurs.  This is the same restriction that we have for the operators
      ``\texttt{\symbol{36}}'' and ``\texttt{\symbol{94}}''.
\item $(r) \in \textsl{Regexp}$ \quad provided $r \in \textsl{Regexp}$

      We can use parentheses in regular expressions to group the operators.
      The precedences of the various operators are specified as follows:
      The  postfix operators ``\texttt{*}'', ``\texttt{?}'', ``\texttt{+}'',
      ``\texttt{\{}$n$\texttt{\}}'' and ``\texttt{\{}$m$,$n$\texttt{\}}'' have the highest
      precedence, while the operator ``\texttt{|}'' has the lowest precedence.
\end{enumerate}
All of the operators discussed so far can also be used with the tool  \textsl{Flex} that is used to
build \texttt{C} parsers. In addition, \textsl{JFlex} supports the negation operator ``\texttt{!}''
and the  \textsl{upto} operator ``\texttt{\symbol{126}}''.  We will discuss these operators later.

The specification of regular expressions is not complete, because we haven't  discussed the notion of a 
\emph{character class} so far.  A character class specifies a set of characters in a compact way.
This is done using the square brackets ``\texttt{[}'' and ``\texttt{]}''.
For example, the vowels can be specified using the regular expression
\\[0.2cm]
\hspace*{1.3cm}
\texttt{[aeiou]}.
\\[0.2cm]
This regular expression serves as an abbreviation of the regular expression
\\[0.2cm]
\hspace*{1.3cm}
\texttt{a|e|i|o|u}.
\\[0.2cm]
In order to specify the set of all lower case Latin characters we can use the regular expression
\\[0.2cm]
\hspace*{1.3cm}
\texttt{[a-z]}
\\[0.2cm]
since we have the following equivalence:
\\[0.2cm]
\hspace*{1.3cm}
$\texttt{[a-z]} \doteq \texttt{a|b|c|d|e|f|g|h|i|j|k|l|m|n|o|p|q|r|s|t|u|v|w|x|y|z}$.
\\[0.2cm]
The set containing  all Latin characters and the underscore is specified vie the regular expression
\\[0.2cm]
\hspace*{1.3cm}
\texttt{[a-zA-Z\_]}.
\\[0.2cm]
With \textsl{JFlex} it is possible to build the complement of a character class.  In order to do
this, we have to use the operator ``\texttt{\symbol{94}}'' immediately after the opening square
bracket.  For example, the regular expression
\\[0.2cm]
\hspace*{1.3cm}
\texttt{[\symbol{94}0-9]}
\\[0.2cm]
specifies all characters that are not decimal digits..  


\examplesEng
In order to aid the understanding of the previous material we provide some examples next.
\begin{enumerate}
\item \texttt{[a-zA-Z][a-zA-Z0-9\_]*}

      This regular expression specifies all those strings that solely consist of Latin characters,
      decimal digits and the underscore and that, furthermore, start with a character.

\item \texttt{\symbol{92}/\symbol{92}/.*}

      This regular expression specifies a one line comment in the programming language \texttt{C}.
      The regular expression matches any string that starts with two slashes and extends to the
      first line break.
\item \texttt{0|[1-9][0-9]*}

      This regular expression matches natural numbers that are coded in the decimal system and that
      do not have leading zeros.  The important thing here is to make sure that a string beginning
      with the character ``\texttt{0}'' must not contain any further digits if the string is
      supposed to represent a natural number.
\end{enumerate}


Our previous discussion of regular expressions is incomplete.  Below are some features that are
unique to the regular expressions supported by \textsl{JFlex}.
\begin{enumerate}
\item Regular expressions can be formatted using white space characters.
      However, white space is not allowed inside character classes.
      Hence, in order to match a space character we can use the regular expression
      ``\texttt{[ ]}'', while the horizontal tab character can be matched using the regular
      expression ``\texttt{\symbol{92}t}''.
\item Inside double quotes all operator symbols but the backslash ``\texttt{\symbol{92}}''loose
      their status as operator symbols and just match themselves.  For example, the regular expression 
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{\symbol{34}/*\symbol{34}}
      \\[0.2cm]
      matches the start of a multi line \texttt{C} comment.  Although both the characters
      ``\texttt{/}'' and ``\texttt{*}'' are operator symbols, they match themselves because they are
      used inside double quotes in the regular expression given above.
\item \textsl{JFlex} supports the negation operator ``\texttt{!}''.  Syntactically, this operator is a
      prefix operator.  If $r$ is a regular expression, then the regular expression
      \\[0.2cm]
      \hspace*{1.3cm}
      $\texttt{!}r$      
      \\[0.2cm]
      matches all those strings that are not matched by $r$.

      The precedence of the negation operator ``\texttt{!}'' is lower than the precedence of the
      postfix operators ``\texttt{+}'', ``\texttt{*}'', ``\texttt{?}'', ``\texttt{\{$m$\}}'', and
      ``\texttt{\{$m$, $n$\}}'', but higher than the precedence of concatenation of regular expressions.
      Therefore, the regular expression
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{!a+b} \quad is equivalent to \quad
      \texttt{(!(a+))b}.
      \\[0.2cm]
      The negation operator is very useful.  For example, in order to recognize multi line comments
      in the programming language \texttt{C}, we can use the following regular expression
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{\symbol{34}/*\symbol{34} !([\symbol{94}]* \symbol{34}*/\symbol{34} [\symbol{94}]*) 
              \symbol{34}*/\symbol{34}}
      \\[0.2cm]
      Let us discuss this regular expression in detail:
      \begin{enumerate}
      \item First, we have to match the substring  ``\texttt{/*}''.  This is done by the regular expression
            \\[0.2cm]
            \hspace*{1.3cm}
            \texttt{\symbol{34}/*\symbol{34}}.
            \\[0.2cm]
            We have enclosed the substring \texttt{/*} in double quotes to prevent these characters
            from acting as operators.
      \item The inner part of a multi line comment must not contain the substring ``\texttt{*/}''.
            The regular expression ``\texttt{[\symbol{94}]}'' specifies the complement of the empty
            character class.  Hence, it specifies an arbitrary character. 
            Therefore the regular expression
            \\[0.2cm]
            \hspace*{1.3cm}
            \texttt{[\symbol{94}]* \symbol{34}*/\symbol{34} [\symbol{94}]*}
            \\[0.2cm]
            matches any string that  contains the string ``\texttt{*/}''.  This string may be
            preceded and succeeded by arbitrary characters. Therefore, the negation of
            this regular expression specifies exactly those strings that can appear inside a multi
            line comment: The only requirement in a multi line comment is that the string between
            the opening  ``\texttt{/*}'' and the closing ``\texttt{*/}'' must not contain the
            substring ``\texttt{*/}''.
      \item A multi line comment ends with the substring ``\texttt{*/}'' which is matched by the
            corresponding regular expression.
      \end{enumerate}
      The  negation operator can be used to specify the intersection of two regular expressions
      $r_1$ and $r_2$:  Using  De Morgan's laws from propositional logic we have that
      \\[0.2cm]
      \hspace*{1.3cm}
      $f_1 \wedge f_2 \leftrightarrow \neg(\neg f_1 \vee \neg f_2)$
      \\[0.2cm]
      holds for any propositional formul\ae\  $f_1$ und $f_2$.  Hence, the intersection of two regular
      expressions $r_1$ and $r_2$ can be defined as
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{!(!$r_1$|!$r_2$)}.
      \\[0.2cm]
      This regular expression matches all those strings that are matched by both
      $r_1$ and $r_2$.

      Experience shows that the regular expressions that contain nested applications of the
      negation operator lead to finite state machines that may have huge numbers of states.
      Hence this feature should be used with caution.
\item As a further convenience,  \textsl{JFlex} provides the \emph{upto} operator ``\texttt{\symbol{126}}''.
      If $r$ is a regular expression, the regular expression
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{\symbol{126}}$r$
      \\[0.2cm]
      specifies any string that ends in $r$ but does not contain $r$ except at the end.
      Using the upto operator, multi line comments of the programming language \texttt{C} can be
      specified using the following regular expression:
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{\symbol{34}/*\symbol{34} \symbol{126}\symbol{34}*/\symbol{34}}
      \\[0.2cm]
      This regular expression works as follows:  A multi line comment starts with the string
      ``\texttt{/*}'' and ends with the first occurrence of the string ``\texttt{*/}''.

      Internally, the upto operator is implemented using the negation operator.  The regular expression
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{\symbol{126}}$r$ \qquad is translated into the regular expression \qquad
      \texttt{!([\symbol{94}]* $r$ [\symbol{94}]*) $r$}.
      \\[0.2cm]
      Here, ``\texttt{!([\symbol{94}]* $r$ [\symbol{94}]*)}'' specifies any string that does not
      contain $r$.  This string then has to be followed by $r$.
\item \textsl{JFlex} supports certain character classes that are predefined in \textsl{Java}.
      For example, the regular expression
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{[:digit:]}
      \\[0.2cm]
      specifies a digit.  The following character classes are provided in \textsl{JFlex}.  Each
      of these character classes corresponds to a method in the class \texttt{java.lang.Character}:
      \begin{enumerate}
      \item \texttt{[:jletter:]} is implemented via the method
            $\texttt{isJavaIdentifierStart}()$.
            
            Hence, the regular expression \texttt{[:jletter:]} specifies those characters that cause
            the method 
            \\[0.2cm]
            \hspace*{1.3cm}
            $\mathtt{Character}.\texttt{isJavaIdentifierStart}(c)$
            \\[0.2cm]
            to return the result \texttt{true}.
      \item \texttt{[:jletterdigit:]} is reduced to the method
            $\texttt{isJavaIdentifierPart}()$.
      \item \texttt{[:letter:]} is reduced to the method
            $\texttt{isLetter}()$.
      \item \texttt{[:digit:]} is reduced to the method
            $\texttt{isDigit}()$.
      \item \texttt{[:uppercase:]} is reduced to the method
            $\texttt{isUppercase}()$.
      \item \texttt{[:lowercase:]} is reduced to the method
            $\texttt{isLowercase}()$.
      \end{enumerate}
\item Furthermore,  \textsl{JFlex} supports  unicode character classes using the syntax 
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{\symbol{92}p\{\textsl{className}\}}.
      \\[0.2cm]
      Here, \textsl{className} can be any unicode character class.  For example, 
      the unicode character class \texttt{greek} is the set of all Greek letters.  Hence, the
      regular expression
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{\symbol{92}p\{greek\}}
      \\[0.2cm]
      can be used to search for Greek letters.  In order to negate a  unicode character class we can
      use the syntax
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{\symbol{92}P\{\textsl{className}\}}.
      \\[0.2cm]
      For example, the regular expression
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{\symbol{92}P\{greek\}}
      \\[0.2cm]
      matches all characters that are not Greek letters.
      
      If you are interested in knowing which unicode character classes exist, you can call 
      \texttt{jflex} using the following command:
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{jflex -uniprops 7.0}
      \\[0.2cm]
      Here, the ``\texttt{7.0}'' specifies the version of  unicode that is supported.
 \end{enumerate}

\section{\textsl{JFlex} Options}
This section discusses the most important options that can be used in the options part of a 
\textsl{JFlex} specification.  All options start with the character ``\texttt{\%}''.
This character has to be the first character in the line.  Hence, an option must not be indented.
\begin{enumerate}
\item \texttt{\%char}

      This options causes the characters to be counted.  If this option is used, the actions can use
      the variable \texttt{yychar}.  This  variable is of type \texttt{int} and it contains the
      number of characters that have been processed by the scanner so far.
\item \texttt{\%line}

      This option causes lines to be counted.  If this option is specified, the
      variable \texttt{yyline} contains the number of lines that have been read.
\item \texttt{\%column}

      This option counts how many characters have been read since the last line break.
      Ths number is stored in the variable \texttt{yycolumn}.  Hence,  \texttt{yycolumn} contains
      the column of the last character that has been read.
\item \texttt{\%cup}

      This option specifies that \textsl{JFlex} is used to generate a scanner that is to be used by
      a parser generated from the  parser generator \textsc{Cup}.  We will explain and use this
      option later once we start to discuss \textsc{Cup}.
\item \texttt{\%ignorecase}

      If this option is used, then the case of the characters is ignored.  For example, with this
      option the regular expression
      ``\texttt{[a-z]+}'' will also match the string ``\texttt{ABC}''.
\end{enumerate}

\section{A Complex Example: Evaluating an Exam}
This sections presents a more complex example that shows some of the power of \textsl{JFlex}.  The
task at hand is the evaluation of an exam.  When I mark an exam I create a file that has a format
similar to the example shown in Figure \ref{fig:result.txt}. 

\begin{figure}[!h]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.8cm,
                  xrightmargin  = 0.8cm,
                  commandchars  = \\\{\}
                ]
    Class: Algorithms and Complexity
    Group: TIT09AID
    
    Exercise:      1. 2. 3. 4. 5. 6.
    Jim Smith:     9 12 10  6  6  0
    John Slow\footnote{You know nothing, John Slow.}:\,    4  4  2  0  -  -
    Susi Sorglos:  9 12 12  9  9  6
\end{Verbatim}
\vspace*{-0.3cm}
\caption{Results of an Exam}
\label{fig:result.txt}
\end{figure}

\footnotetext[1]{You know nothing, John Slow.}

\begin{enumerate}
\item The first line contains the keyword ``\texttt{Class}'', a colon ``\texttt{:}'', and then the
      name of the lecture. 
\item The second line specifies the group that has taken the exam.
\item The third line is empty.
\item The fourth line specifies the exercises.
\item After that, there is a table.  Every row in this table lists the scores achieved by a student
      for each of the exercises.  We find the name of each student at the start of each row.  The
      name is followed by a colon and after that there is a list of the scores achieved for each
      exercise.  If an exercise has not been attempted at all, the corresponding column contains a hyphen
      ``\texttt{-}''.
\end{enumerate}
The \textsl{JFlex} program that we are going to develop will first compute the total score achieved
by a student by summing up the scores she reached for each exercise.  This total score is stored in
the variable \texttt{sumPoints}.  The mark is then computed according to the formula
\\[0.2cm]
\hspace*{1.3cm}
$\ds\texttt{mark} = 7 - 6 \cdot \frac{\;\texttt{sumPoints}\;}{\texttt{maxPoints}}$.
\\[0.2cm]
Here, the  variable \texttt{maxPoints} specifies the score that is needed to accomplish the best
mark. Note that in  Germany the best mark is 1.0.  This number is later provided as an argument to the
program generated by \textsl{JFlex}.


\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.0cm,
                  xrightmargin  = 0.0cm,
                ]
    %%
    %class Exam
    %int        // declare return type of yylex
    %line
    %column
    %unicode
    %{
        public int mMaxPoints = 0;
        public int mSumPoints = 0;
        public double mark() {
            return 7.0 - 6.0 * mSumPoints / mMaxPoints;
        } 
        public void errorMsg() {
            System.out.printf("invalid character '%s' at line %d, column %d\n", 
                              yytext(), yyline + 1, yycolumn + 1); 
        }    
        public static void main(String argv[]) {
            if (argv.length != 2) {
                System.out.println("Usage: java Exam <inputfile> <maxPoints>");
            } else {
                try {
                    Exam scanner       = new Exam(new java.io.FileReader(argv[0]));
                    scanner.mMaxPoints = new Integer(argv[1]);
                    scanner.yylex();
                } catch (java.io.FileNotFoundException e) {
                    System.out.println("File not found : \"" + argv[0] + "\"");
                } catch (java.io.IOException e) {
                    System.out.println("IO error scanning \"" + argv[0] + "\"");
                    System.out.println(e);
                } 
            }
        }
    %}
    NUMBER = 0|[1-9][0-9]*
    NAME   = [A-Za-z]+[ ][A-Za-z\-]+

    %%    

    [A-Za-z]+:.*\R { /* skip header                         */ }
    {NAME}:[ \t]+  { System.out.print(yytext()); 
                     mSumPoints = 0;
                   }
    {NUMBER}       { mSumPoints += new Integer(yytext());      }
    -              { /* skip hyphens                        */ }
    [ \t]          { /* skip white space                    */ }
    ^[ \t]*\R      { /* skip empty line                     */ }
    \R             { System.out.printf(" %3.1f\n", mark());    }
    .              { errorMsg();                               }
\end{Verbatim}
\vspace*{-0.3cm}
\caption{Marking an exam using \textsl{JFlex}.}
\label{fig:exam.jflex}
\end{figure}

Figure \ref{fig:exam.jflex} on page \pageref{fig:exam.jflex} presents the \textsl{JFlex} scanner
that is used to evaluate files like the one shown in Figure \ref{fig:result.txt}.  From this code,
\textsl{JFlex} generates the \textsl{Java} program that can the be used to compute the scores.
\begin{enumerate}
\item As we neither use a \texttt{package} declaration nor need an \texttt{import} statement,
      the first part of the \textsl{JFlex} specification is empty.  Therefore, our scanner
      specification starts with the separator string ``\texttt{\symbol{37}\symbol{37}}''
      that separates the first part from the second part.
\item Line 2 defines the name of the generated class.
\item Line 3 specifies via the option ``\texttt{int}'' that the return type of the scanner
      method \textsl{yylex()} has to be the type  \texttt{int}.

      This is necessary since we have not declared the scanner as a 
      \texttt{standalone} scanner.  If  a scanner is not a standalone scanner, by default the return
      type of the method \texttt{yylex} is the type \texttt{Yytoken}.
      However, the class \texttt{Yytoken} is not defined by \textsl{JFlex}.  The reason is that by default
      \textsl{JFlex} expects any scanner that is not declared to be \texttt{standalone}
      to be attached to a parser that declares the type \texttt{Yytoken}.  However, as we do not
      intend to attach a parser, the type \texttt{Yytoken} is not defined.  In order to avoid
      that the return type of the method \texttt{yylex()} is declared to be \texttt{Yytoken},
      we specify the return type explicitly via the the option ``\texttt{\symbol{37}int}''.

      At this point you might ask why we did not declare the scanner to be \texttt{standalone}.
      The problem is that in a \texttt{standalone} scanner the method \textsl{main} is defined
      by \textsl{JFlex}.  However, in this example we need to define the method \textsl{main}
      ourselves as we need to call the generated program with two arguments:
      \begin{enumerate}
      \item The first argument is the name of file to be evaluated.
      \item The second argument is the number of points that is needed to achieve the best mark.
      \end{enumerate}
      The method main that is generated automatically only expects the name of the file to be
      scanned as its argument and therefore this method does not fit our bill.
\item In line 4 and line 5 we use the options ``\texttt{\symbol{37}line}'' and
      ``\texttt{\symbol{37}column}'' to have both the line number and the column number available.
      This information will come handy when we want to locate syntax errors in the input file.
\item Line 8 and line 9 declare the variables  \texttt{mMaxPoints} und
      \texttt{mSumPoints}.  These variable will be member variables of the class \texttt{Exam} that
      is generated by \textsl{JFlex}.
\item Line 10 -- 12 define the function \textsl{mark()} that is used to compute the score of an exam.
\item Line 13 -- 16 define the function \textsl{errorMsg()} that is used to provide an error message
      in case an unexpected character is encountered.  This function prints the position of the
      invalid character.  Since \textsl{JFlex} starts to count lines and columns with 0 we have to
      add $1$ to the variables \texttt{yyline} and \texttt{yycolumn}.
\item The workhorse of the scanner is the method \textsl{main()} defined in line 17 -- 33.
      \begin{enumerate}
      \item In line 18 we have to check that the generated scanner is called with two arguments.
            The first argument is the name of the file containing the results, while the second
            argument is the score needed to achieve the best mark.  If the program is called with
            either more than two or less than two arguments, usage information is printed.
      \item Line 22 initializes the variable scanner as an object of class \texttt{Exam}.
      \item Line 23 sets the variable \texttt{maxPoints} to the value provided by the user when
            calling the program.
      \item Line 24 starts the scanner by calling the function \textsl{yyylex()}.  This function
            reads the given file and executes the scanner rules for the input given in that file.
      \item In the lines 25 -- 30 we deal with various exceptions that might occur.   
      \end{enumerate}
\item Next, the lines 34 and 35 define two \emph{macros}.  A macro is just an abbreviation that can
      be used to write a regular expressions more succinctly.
      \begin{enumerate}
      \item Line 35 defines the macro  \texttt{NUMBER}.  The value of this macro is the regular
            expression recognizing natural numbers.
      \item Line 36 defines the macro \texttt{NAME}.  The regular expression
            \\[0.2cm]
            \hspace*{1.3cm}
            \texttt{[A-Za-z]+[ ][A-Za-z\symbol{92}-]+}
            \\[0.2cm]
            specifies that a name consists of a first name and a family name that are separated by a
            blank character.  These names are sequences of Latin character in either lower or upper
            case.  Furthermore, the family name might contain a hyphen.  Note that we have to escape
            the hyphen.
      \end{enumerate}
\item The scanner rules are given in line 39 -- 48.
      \begin{enumerate}
      \item The rule in line 39 is used to read the two header lines that specify the name of the
            class and the name of the group.
            Both of these lines consist of a single word that is followed by a colon.  The text
            after the colon is unimportant for the evaluation.  Therefore, these two lines are just skipped.
      \item The rule in line 40 reads the name of the student which must be followed by a colon.
            It also reads any white space following the colon.  Both the name and the colon
            including the white space is then printed.

            The reason that we do not only print the name but also the white space is formatting.
            Different names have different length.  By printing both the name and the white space we
            are able to format the output in the same way the input is formatted. 

            Furthermore, we have to reset the variable \texttt{mSumPoints} to 0.  This is necessary
            because in general this variable still contains the score of the last student.
      \item The rule in line 43 reads the score that a student has achieved by doing an exercise.
            As the function \textsl{yytext()} returns a string, this string has to be converted into
            an integer.  Finally, this integer is added to the total score stored in the variable
            \texttt{mSumPoints}. 
      \item If a student hasn't worked on an exercise, the input file contains a hyphen 
            ``\texttt{-}'' for this exercise.  The rule in line 44 reads this hyphen and skips it,
            since exercises that have not been worked on do not contribute to the running total.
      \item In the same way, the rule in line 45 skips over white space.
      \item The rule in line 46 skips an empty line.
      \item Since all other line breaks have been dealt with by the previous rules, the rule in line
            47 deals with the case that we encounter a line break at the end of a 
            line containing the scores of a student.  In this case, the mark of the student is
            computed and printed with a precision of one decimal place.
      \item The rules given so far are sufficient to process an input file that is syntactically
            correct.  The last rule in line 48 deals with any unexpected character.  The regular
            expression ``\texttt{.}'' matches every character.  If this rule is ever reached, this
            means that a character has not been processed by the previous rules and hence there is a
            syntax error.  In this case, an error message is printed using the function
            \textsl{errorMsg()} defined above.
      \end{enumerate}
\end{enumerate}

\section{Scanner States}
Although many interesting syntactical constructions can be described through regular expressions, often
the regular expressions that are needed can get quite unwieldy.  A case in point is the regular
expression that describes multi line comments in the language \textsl{Java}.  In languages like
\textsl{Java}, \texttt{C}, or \texttt{C++}, a multi line comment has the form
\\[0.2cm]
\hspace*{1.3cm}
\texttt{/*} $\cdots$ \texttt{*/}
\\[0.2cm]
If we had to describe multi line comments with a regular expression that does use neither the
negation operator nor the upto operator\footnote{Most of the tools that support regular expressions
  do not support the negation operator, nor do they support the upto operator}, 
then we would have to use a regular expression that looks similar to the following regular expression:
\begin{equation}
  \label{eq:multiline-comment}
\texttt{\symbol{92}/\symbol{92}*([\symbol{94}*]|\symbol{92}*+[\symbol{94}*/])*\symbol{92}*+\symbol{92}/}  
\end{equation}
First, the expression is quite difficult to read.  One reason is that the operator symbols
``\texttt{/}'' and ``\texttt{*}'' have to be escaped with a backslash character.  The other problem
is that the mechanics of this regular expression is quite involved.  Let us discuss the different
parts of the regular expression given above:
\begin{enumerate}
\item \texttt{\symbol{92}/\symbol{92}*} 

      This part specifies the string ``\texttt{/*}''.
\item \texttt{([\symbol{94}*]|\symbol{92}*+[\symbol{94}*/])*}
  
      This regular expression specifies text that is surrounded by the opening string
      ``\texttt{/*}'' and the closing string  ``\texttt{*/}''.  This text must not contain the
      substring ``\texttt{*/}'' because otherwise we would misinterpret a line of the form
      \\[0.2cm]
      \hspace*{1.3cm} \texttt{/* first */ ++n; /* second */}
      \\[0.2cm]
      since we would interpret the command ``\texttt{++n;}'' as a part of the comment.
      
      The first part of the regular expression above is the expression ``\texttt{[\symbol{94}*]}''.
      This part recognizes any character that is different from the character ``\texttt{*}''.  As
      long as there is no  ``\texttt{*}'', the text can not contain the substring ``\texttt{*/}''.
      However, the problem is that the character ``\texttt{*}'' is legal inside a
      multi line comment.  However, this character must not be followed by the character ``\texttt{/}''.
      Hence, the alternative ``\texttt{\symbol{92}*+[\symbol{94}*/]}'' specifies those strings
      that might contain any number of ``\texttt{*}'' characters but that have to be followed by a character
      that is both different from the character ``\texttt{/}'' and from the character ``\texttt{*}''.
      
      Hence, the expression  ``\texttt{[\symbol{94}*]|\symbol{92}*+[\symbol{94}*/]}''
      specifies a character that is different from  ``\texttt{*}'', or a sequence of ``\texttt{*}''
      characters that are followed by a character different from ``\texttt{/}''.  As these sequence
      can occur any number of times, the expression is enclosed in parentheses and decorated with
      the quantifier ``\texttt{*}''.   
\item \texttt{\symbol{92}*+\symbol{92}/}
  
      This regular expression specifies the end of the multi line comment.
      The end can consist of any positive number of  ``\texttt{*}'' characters that are followed by
      the character  ``\texttt{/}''.  If we would just use the regular expression
      ``\texttt{\symbol{92}*\symbol{92}/}'', then we would not be able to identify comments of the form
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{/*** blah ***/}
      \\[0.2cm]
      correctly, since the second part of the regular expression discussed previously does only allow sequences
      of the character ``\texttt{*}'' that are followed by a character that is different from both
      ``\texttt{*}'' and ``\texttt{/}''.
\end{enumerate}

\begin{figure}[!h]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.8cm,
                  xrightmargin  = 0.8cm,
                ]
    /**
      remove C comments from a file 
    */
    
    %%
    
    %class Decomment
    %standalone
    %unicode
    
    %%
    
    \/\*([^*]|\*+[^*/])*\*+\/ { /* skip multi  line comments */ }
    \/\/.*                    { /* skip single line comments */ }
\end{Verbatim}
\vspace*{-0.3cm}
\caption{Entfernung von Kommentaren aus einem C-Programm.}
\label{fig:decomment.jflex}
\end{figure}

\noindent
Figure \ref{fig:decomment.jflex} on page \pageref{fig:decomment.jflex} shows a \textsl{JFlex}
program that can be used to remove all comments from a \texttt{C} program.  This program will remove
both single line comments of the form
\\[0.2cm]
\hspace*{1.3cm}
 ``\texttt{//} $\cdots$''
\\[0.2cm]
as well as multi line comments of the form
\\[0.2cm]
\hspace*{1.3cm}
``\texttt{/*} $\cdots$ \texttt{*/}. 
\\[0.2cm]
At this point, you might ask yourself ``What happens to those parts of the program that are not comments?''.
These parts are dealt with by the  \emph{default rule} of \textsl{JFlex}:  Every character of the
input that is not matched by any of the \textsl{JFlex} rules is just echoed, i.e.~it is printed to
the stream standard out.   Hence, the \textsl{JFlex} program shown above will remove the comments from a
program and it will print the rest of the program unchanged.

Although this program is quite concise, the logic of the regular expression is very involved and,
because of that, the program is difficult to understand and to maintain. 
We have to options to simplify this program.
\begin{enumerate}
\item We could use the upto operator.  If we were to use \textsl{JFlex}, this is by far the best
      option.  However, not every scanner generator supports this operator.  For example, if we
      would use \textsl{Flex} instead of \textsl{JFlex}, we would not have the upto operator available.
\item Alternatively, we can use \emph{scanner states}.
      We will discuss this option using a second example that is given in the following subsection.
\end{enumerate}

\subsection{Removal of  \textsc{Html} Tags}
In this subsection we will develop a program that is able to convert an 
\textsc{Html} file into a pure text file.  This program is actually quite useful: Some years ago I
had a student that was blind.  If he read a web page, he would use his Braille display.  For him,
the \textsc{Html} markup was of no use so if the markup was removed, he could read web pages faster.

The \textsl{JFlex} program shown in Figure \ref{fig:html2txt.jflex} works as follows:
\begin{enumerate}
\item First, the head of an  \textsc{Html} file is removed.  The head of an \textsc{Html} file is
      enclosed in the  tags ``\texttt{<head>}'' and ``\texttt{</head>}''.
\item Furthermore, the \textsl{JavaScript} that is part of the \textsc{Html} file is also removed.
\item Finally, all  \textsc{Html} tags are removed.
\end{enumerate}
All this is done via the use of so called \emph{scanner states}.  In the example, there are two
scanner states.  They are declared via the keyword
``\texttt{\symbol{37}xstate}''. 

\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.8cm,
                  xrightmargin  = 0.8cm,
                ]
    package Converter;
    
    %% 
    
    %class Html2Txt
    %standalone
    %line
    %unicode
    
    %xstate header script
    %%
    
    "<head>"            { yybegin(header);         }
    "<script"[^>]+">"   { yybegin(script);         }
    "<"[^>]+">"         { /* skip html tags */     }
    \R+                 { System.out.print("\n");  }
    &nbsp;              { System.out.print(" ");   }
    &auml;              { System.out.print("\"a");   }
    &ouml;              { System.out.print("\"o");   }
    &uuml;              { System.out.print("\"u");   }
    &Auml;              { System.out.print("\"A");   }
    &Ouml;              { System.out.print("\"O");   }
    &Uuml;              { System.out.print("\"U");   }
    &szlig;             { System.out.print("{\ss}");   }
    
    <header>"</head>"   { yybegin(YYINITIAL);      }
    <header>.|\R        { /* skip anything else */ }
    
    <script>"</script>" { yybegin(YYINITIAL);      }
    <script>.|\R        { /* skip anything else */ }
\end{Verbatim}
\vspace*{-0.3cm}
\caption{Transformation einer \textsc{Html}-Datei in eine reine Text-Datei}
\label{fig:html2txt.jflex}
\end{figure}

We proceed to discuss the details of the \textsl{JFlex} program shown in Figure \ref{fig:html2txt.jflex}.
\begin{enumerate}
\item Line  10 declares the scanner states \texttt{header} and \texttt{script}.  The keyword ``\texttt{\%xstate}''
      tells us that these states are  \emph{exclusive} scanner states.  We will discuss the difference
      between exclusive and inclusive states later.
      The general syntax of state declaration is as follows:
      \begin{enumerate}
      \item A state declaration is either started with the keyword ``\texttt{\symbol{37}xstate}''
            or the keyword ``\texttt{\symbol{37}state}''.  The keyword
            ``\texttt{\symbol{37}xstate}'' declares \emph{exclusive} states, while
            ``\texttt{\symbol{37}state}'' declares  \emph{inclusive} states.  The 
            difference between these two kinds of states is discussed later.
      \item After the keyword specifying the states as either inclusive or exclusive we have a list
            of the names of the states.  These names are separated by blanks.
      \end{enumerate}
\item In line 13 we recognize the string  ``\texttt{<head>}''.  In this case, we execute the action 
      ``\texttt{yybegin(header)}''.  This action switches the state of the scanner from the default
      state ``\texttt{YYINITIAL}'' to  the state ``\texttt{header}''.   
      As we had declared the state \texttt{header} to be an  exclusive state, the scanner is only
      able to execute those rules that are marked with the prefix ``\texttt{<header>}''.
      If the state had been declared as an inclusive state, then all rules that are not prefixed
      with a state would also be applicable.  
      
      We find rules for the state ``\texttt{header}'' in the lines  26 and 27.
\item Line 14 switches to the state ``\texttt{script}'' if the scanner encounters an opening
      \texttt{script} tag.
\item Line  15 reads all remaining tags.  Since the action is empty, these tags are removed.
\item Line 16 replaces the string  ``\texttt{\&nbsp;}'' by a blank.
\item The following lines replaces the  \textsc{Html} representation of strange German characters with
      the corresponding characters.
\item Line 26 is declared to be a rule for the state ``\texttt{header}''.  Hence, this rule is only
      active if the scanner is in the state ``\texttt{header}''.  This rule searches for the closing tag
      ``\texttt{</head>}''.  If this tag is found, the scanner changes back into the default state
      \texttt{YYINITIAL}.  In the default state, the scanner uses only those rules that are not
      prefixed with a state. 
\item Line 27 contains another rule that is only used in the state  ``\texttt{header}''.
      This rule reads an arbitrary character, which is not processed further and hence is simply
      discarded. 
\item The lines  29 and 30 contain similar rules that are used in the state
      ``\texttt{script}''.
\end{enumerate}
\pagebreak

\exerciseEng
Some programming languages allow nested comments.  Create a \textsl{JFlex} program that is able to
remove nested comments of the form
\\[0.2cm]
\hspace*{1.3cm}
\texttt{/*} $\cdots$ \texttt{*/}
\\[0.2cm]
from a given program.  Furthermore, assume that the program might contains strings that are
contained in double quotes.  Now if either the character sequence ``\texttt{/*}'' or the character
sequence ``\texttt{*/}'' occurs inside a string, then these character sequences should not be
interpreted as comment delimiters. 
\eox
\vspace*{0.3cm}

The next exercise is meant to improve the fun factor of my lecture.

\exerciseEng
The purpose of this exercise is to transform \href{http://www.latex-project.org}{\LaTeX} into 
\href{http://rypress.com/tutorials/mathml}{\textsc{MathML}}.  \LaTeX\ is a document markup language
that is especially well suited to present text that contains mathematical formul\ae.  In fact, these
lecture notes have all been typeset using \LaTeX.  \textsc{MathML} is the part of \textsc{Html} that
deals with the representation of mathematical formul\ae.  As \LaTeX\ provides a very rich
document markup language and we can only afford to spend a few hours on this exercise, we confine
ourselves to a small subset of \LaTeX.  Figure \ref{fig:input.tex} on page \pageref{fig:input.tex}
shows the example input file that we want to transform in \textsc{Html}.  If this example file is
typeset using \LaTeX, it is displayed as shown in Figure \ref{fig:input.pdf} on page
\pageref{fig:input.pdf}.  The program that you are
going to develop should transform the \LaTeX\ input file into an \textsc{Html} file.  For your
convenience, all these files are available in the github directory 
\\[0.2cm]
\hspace*{1.3cm}
\href{https://github.com/karlstroetmann/Formal-Languages/tree/master/JFlex/LaTeX2HTML}{\texttt{JFlex/LaTeX2HTML}}.

\begin{figure}[!ht]
  \centering
\begin{verbatim}
    \documentclass{article}
    \begin{document}
    The sum of the squares of the first $n$ natural numbers is given as:
    $$ \sum\limits_{i=1}^{n} i^{2} = \frac{1}{6} \cdot n \cdot (n+1) \cdot (2\cdot n + 1). $$
    According to Pythagoras, the length of the hypotenuse of a right triangle is
    the square root of the squares of the length of the two catheti:
    $$ c = \sqrt{a^{2} + b^{2}}.  $$
    The area of a circle is given as 
    $$  A = \pi \cdot r^{2},   $$ 
    while its circumference satisfies
    $$ C = 2 \cdot \pi \cdot r.  $$
    \end{document}
    \end{verbatim}
  \caption{An example \LaTeX\ input file.}
  \label{fig:input.tex}
\end{figure}

\begin{figure}[!ht]
  \centering
  \framebox{
  \begin{minipage}{0.8\linewidth}
    The sum of the squares of the first $n$ natural numbers is given as:
    $$ \sum_{i=1}^{n} i^{2} = \frac{1}{6} \cdot n \cdot (n+1) \cdot (2\cdot n + 1). $$
    According to Pythagoras, the length of the hypotenuse of a right triangle is
    the square root of the squares of the length of the two catheti:
    $$ c = \sqrt{a^{2} + b^{2}}.  $$
    The area $A$ of a circle is given as 
    $$  A = \pi \cdot r^{2},   $$ 
    while its circumference satisfies
    $$ C = 2 \cdot \pi \cdot r.  $$   
  \end{minipage}}
  \caption{Output produced by the \LaTeX\ file shown in Figure \ref{fig:input.tex}}
  \label{fig:input.pdf}
\end{figure}

In order to do this exercise, you have to understand a little bit about \LaTeX\ and about 
\textsc{MathML}.  In the following, we discuss those features of these two language that are needed.
\begin{enumerate}
\item A \LaTeX\ input file has the following structure:
      \begin{enumerate}
      \item The first line list the type of the document.  In our example, it reads
            \\[0.2cm]
            \hspace*{1.3cm}
            \texttt{\symbol{92}documentclass\{article\}}.
            \\[0.2cm]
            This line will be transformed into the following \textsc{Html}:
            \begin{verbatim}
    <html>
    <head>
    <script type="text/javascript"
    src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
    </script>
            \end{verbatim}
            Here, the \texttt{<script>} tag is necessary in order for the \textsc{MathML} 
            to be displayed correctly.
      \item The next line has the form:
            \\[0.2cm]
            \hspace*{1.3cm}
            \texttt{\symbol{92}begin\{document\}}
            \\[0.2cm]
            This line precedes the content and should be translated into the tag
            \\[0.2cm]
            \hspace*{1.3cm}
            \texttt{<body>}.
      \item After that, the \LaTeX\ file contains text that contains mathematical formula.
      \item The \LaTeX\ input file finishes with a line of the form
            \\[0.2cm]
            \hspace*{1.3cm}
            \texttt{\symbol{92}end\{document\}}.
            \\[0.2cm]
            This line should be translated into the tags
            \\[0.2cm]
            \hspace*{1.3cm}
            \texttt{</body></html>}.
      \end{enumerate}
\item In \LaTeX, an inline formula is started and ended with a single dollar symbol
      ``\texttt{\symbol{36}}''.  
      In \textsc{MathML}, an inline formula is written as
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{<math xmlns="http://www.w3.org/1998/Math/MathML" display='inline'>$\cdots$</math>}.
      \\[0.2cm]
      Here, I have used ``$\cdots$'' to represent the mathematical content of the formula.
\item In \LaTeX, a formula that is displayed in its own line is started and ended with the string
      ``\texttt{\symbol{36}\symbol{36}}''.  
      In \textsc{MathML}, the formul\ae\ are called \emph{block formul\ae} and are written as
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{<math xmlns="http://www.w3.org/1998/Math/MathML" display='block'>$\cdots$</math>}.
      \\[0.2cm]
      Again, I have used ``$\cdots$'' to represent the mathematical content of the formula.
\item While in \LaTeX\ a mathematical variable does not need any special markup, in \textsc{MathMl}
      a mathematical variable is written using the tags 
      \texttt{<mi>} and \texttt{</mi>}.  For example, the mathematical variable $n$ is written as    
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{<mi>n</mi>}.
\item While in \LaTeX\ a number does not need any special markup, in \textsc{MathMl}
      a number is written using the tags 
      \texttt{<mn>} and \texttt{</mn>}.  For example, the number $3.14149$ is written as    
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{<mn>3.14159</mn>}.
\item In \LaTeX\ the mathematical constant $\pi$ is written using the command ``\texttt{\symbol{92}pi}''.
      In \textsc{MathMl}, we have to make use of the \textsc{Html} entity ``\texttt{\&pi;}'' and
      hence we would write $\pi$ as
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{<mn>\&pi;</mn>}.
\item In \LaTeX\ the multiplication operator ``$\cdot$'' is written using the command ``\texttt{\symbol{92}cdot}''.
      In \textsc{MathMl}, we have to make use of the \textsc{Html} entity ``\texttt{\&sdot;}'' and
      hence we would write ``$\cdot$'' as
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{<mop>\&sdot;</mop>}.
\item While in \LaTeX\ most operator symbols stand for themselves, in \textsc{MathMl}
      an operator is surrounded by the tags 
      \texttt{<mop>} and \texttt{</mop>}.  For example, the operator $+$ is written as    
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{<mop>+</mop>}.
\item In \LaTeX, raising an expression $e$ to the $n$th power is done using the operator
      ``\texttt{\symbol{94}}''.  Furthermore, the exponent should be enclosed in the curly braces
      ``\texttt{\{}'' and ``\texttt{\}}''.  For example, the code to produce the term $x^2$ is
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{x\symbol{94}\{2\}}.
      \\[0.2cm]
      In \textsc{MathMl}, raising an expression to a power is achieved using the tags
      \texttt{<msup>} and \texttt{</msup>}.  For example, in order to display the term $x^2$, we
      have to write  
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{<msup><mi>x</mi><mn>2</mn></msup>}.
\item In \LaTeX, taking the square root of an expression is done using the command
      ``\texttt{\symbol{92}sqrt}''.  The argument has to be enclosed in curly braces.
      For example, in order to produce the output $\sqrt{a+b}$, we have to write
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{\symbol{92}sqrt\{a+b\}}.
      \\[0.2cm]
      In \textsc{MathMl}, taking the square root makes use of the tags \texttt{<msqrt>} 
      and \texttt{</msqrt>}.  The example shown above can be written as
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{<msqrt><mi>a</mi><mop>+</mop><mi>b</mi></msqrt>}.
\item In \LaTeX, writing a fraction is done using the command
      ``\texttt{\symbol{92}frac}''.  This command takes two arguments, the numerator and the
      denominator.  Both of these have to be enclosed in curly braces.
      For example, in order to produce the output $\frac{a+b}{2}$, we have to write
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{\symbol{92}frac\{a+b\}\{2\}}.
      \\[0.2cm]
      In \textsc{MathMl}, a fraction is created via the tags \texttt{<mfrac>} 
      and \texttt{</mfrac>}.  Additionally, if the arguments contain more than a single element,
      each of them has to be enclosed in the tags \texttt{<mrow>} and \texttt{</mrow>}.
      The example shown above can be written as
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{<mfrac><mrow><mi>a</mi><mop>+</mop><mi>b</mi></mrow><mn>2</mn></mfrac>}.
\item In \LaTeX, writing a sum is done using the command
      ``\texttt{\symbol{92}sum\symbol{92}limits}''.  
      This command takes two arguments:  The first argument gives the indexing variable together
      with its lower bound, while the second argument gives the upper bound.  The first argument
      is started using the string ``\texttt{\_\{}'' and ended using the string ``\texttt{\}}'',
      while the second argument is started using the string ``\texttt{\symbol{94}\{}'' and ended using the
      string ``\texttt{\}}''.  For example, in order to produce the output 
      \\[0.2cm]
      \hspace*{1.3cm}
      $\displaystyle\sum\limits_{i=1}^{n} i$,
      \\[0.2cm]
      we have to write
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{\symbol{92}sum\symbol{92}limits\_\{i=1\}\symbol{94}\{n\} i}.
      \\[0.2cm]
      In \textsc{MathMl}, a sum with lower and upper limits is created via the tags
      \texttt{<munderover>} and \texttt{</munderover>} and the \textsc{Html} entity ``\texttt{\&sum}''.
      The tag \texttt{munderover} takes three arguments:
      \begin{enumerate}
      \item The first argument is the operator, so in this case it is the entity ``\texttt{\&sum}''.
      \item The second argument initializes the indexing variable of the sum.
      \item The third argument provides the upper bound.
      \end{enumerate}
      The second argument usually contains more than a single item and therefore has to be enclosed 
      in the tags \texttt{<mrow>} and \texttt{</mrow>}.
      Hence, the example shown above would be written as follows: 
    \begin{verbatim}
    <munderover>
        <mo>&sum;</mo>
        <mrow>
            <mi>i</mi> <mo>=</mo> <mn>1</mn>
        </mrow>
        <mi>n</mi>
    </munderover>
    \end{verbatim}
\end{enumerate}
In order to cut the time necessary to complete this exercise, I have provided a \textsc{Java} class
\texttt{HtmlWriter} that contains a number of useful static methods.  This file is available at
\\[0.2cm]
\hspace*{1.3cm}
\href{https://github.com/karlstroetmann/Formal-Languages/tree/master/JFlex/LaTeX2HTML/HtmlWriter.java}{\texttt{JFlex/LaTeX2HTML/HtmlWriter.java}}.
\\[0.2cm] 
Furthermore, the \texttt{github} directory \texttt{JFlex/LaTeX2HTML} already contains a \texttt{Makefile}.
Additionally, the directory contains the file
\\[0.2cm]
\hspace*{1.3cm}
\href{https://github.com/karlstroetmann/Formal-Languages/tree/master/JFlex/LaTeX2HTML/input.html}{\texttt{JFlex/LaTeX2HTML/input.html}}
\\[0.2cm]
which shows the result of converting the input file ``\texttt{input.tex}'' into \textsc{Html}.
Next, there is a file \texttt{State.java} containing an enumeration that I have found useful for my
solution of the problem.

\remarkEng
The most important problem that you have to solve is the following:  Once you encounter a closing brace
``\texttt{\}}'' you have to know whether this brace closes the argument of a square root, a
fraction, a sum, or an exponent.  You should be aware that, for example, square roots and fractions
can be nested.  Hence, it is not enough to have a single variable that remembers whether you are
parsing, say, a square root or a fraction.  Instead, every time you encounter a string like, e.g.
\\[0.2cm]
\hspace*{1.3cm}
\texttt{\symbol{92}sqrt\{} \quad or \quad \texttt{\symbol{92}frac\{},
\\[0.2cm]
you should store the current state on a stack and set the new state according to whether you have just seen the
keyword ``\texttt{\symbol{92}frac}'' or ``\texttt{\symbol{92}sqrt}'' or whatever else caused the
curly brace to be opened.  When you encounter a closing brace ``\texttt{\}}'', you should 
restore the state to its previous value by looking up this value from the stack.  The github directory
\texttt{JFlex/LaTeX2HTML} already contains both the interface \texttt{Stack.java} as well as the
class \texttt{ArrayStack.java} implementing this interface.
\eox




%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "formal-languages.tex"
%%% End: 

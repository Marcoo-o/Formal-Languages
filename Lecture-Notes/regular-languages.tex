\chapter{The Theory of Regular Languages \label{chapter:regulaere-sprachen}}
A formal language $L \subseteq \Sigma^*$ is called a \blue{regular language} \index{regular language}
if there is a regular expression $r$ such that the language $L$ is specified by $r$, i.e.~if
\\[0.2cm]
\hspace*{1.3cm}
$L = L(r)$ 
\\[0.2cm]
holds.  In Chapter \ref{chapter:finit-state-machines.tex} we have shown that the regular languages
are those languages that are recognized by a finite state machine.  In this chapter, we show
that regular languages have certain \blue{closure properties}:
\begin{enumerate}[(a)]
\item The \blue{union} $L_1 \cup L_2$ of two regular languages $L_1$ and $L_2$ is a regular language.
\item The \blue{intersection} $L_1 \cap L_2$ of two regular languages $L_1$ und $L_2$ is a regular language.
\item The \blue{complement} \index{complement of a language} $\Sigma^* \backslash L$ of a regular language $L$ is a regular language.
\end{enumerate}
As an application of these closure properties we will then show how it is possible to decide whether two
regular expressions are \blue{equivalent}, i.e.~we present an algorithm that takes two regular expressions
$r_1$ and $r_2$ as input and checks, whether 
\\[0.2cm]
\hspace*{1.3cm}
$r_1 \doteq r_2$
\\[0.2cm]
holds.  After that, we discuss the \blue{limits} of regular languages.  To this end, we prove the
\href{http://en.wikipedia.org/wiki/Pumping_lemma_for_regular_languages}{\emph{pumping lemma}}.
Using the pumping lemma we will be able to show that, for example, the language
\\[0.2cm]
\hspace*{1.3cm} $\{ \mathtt{a}^n \mathtt{b}^n \mid n \in \mathbb{N} \}$
\\[0.2cm]
is not regular.  To summarize, this chapter 
\begin{itemize}
\item discusses closure properties of regular languages
\item presents an algorithm for checking the equivalence of regular expressions, and
\item shows that certain languages are not regular.
\end{itemize}


\section{Closure Properties of Regular Languages}
In this section we show that regular languages are closed under the Boolean operations
of \blue{union}, \blue{intersection} and \blue{complement}.  We start with the union.

\begin{Proposition}
  If $L_1$ and $L_2$ are regular languages, then the union $L_1 \cup L_2$ is a regular language, too.
\end{Proposition}

\proofEng
As $L_1$ and $L_2$ are regular languages, there exist regular expressions $r_1$ and $r_2$ such that
\\[0.2cm]
\hspace*{1.3cm}
$L_1 = L(r_1)$ \quad and \quad $L_2 = L(r_2)$
\\[0.2cm]
holds.  We define $r := r_1 + r_2$.  Then we have
\\[0.2cm]
\hspace*{1.3cm}
$L(r) = L(r_1 + r_2) = L(r_1) \cup L(r_2) = L_1 \cup L_2$.
\\[0.2cm]
Therefore,  $L_1 \cup L_2$ is a regular language. \qed

\begin{Proposition} \label{satz:schnitt}
  If  $L_1$ and $L_2$ are regular languages, then the intersection $L_1 \cap L_2$ is a regular language, too.
\end{Proposition}

\proofEng
While the proof of the last proposition follows directly from the definition of regular expressions,
we have to do a little more work now. In the previous chapter we saw that for every regular expression
$r$ there is an equivalent deterministic finite state machine $F$, which accepts the language specified by $r$,
and we can also assume that this \textsc{Fsm} is complete. Let $r_1$ and $r_2$ be the regular expressions that
define the languages $L_1$ and $L_2$, i.e.~we have
\\[0.2cm]
\hspace*{1.3cm}
$L_1 = L(r_1)$ \quad und \quad $L_2 = L(r_2)$.
\\[0.2cm]
First, we construct two complete deterministic \textsc{Fsm}s
$A_1$ and $A_2$ that accept these languages, i.e.~we have
\\[0.2cm]
\hspace*{1.3cm}
$L(A_1) = L_1$ \quad and \quad $L(A_2) = L_2$.
\\[0.2cm]
Our goal is to construct a finite state machine $F$ such that $F$ accepts the language
$L_1 \cap L_2$ and nothing else.  As every finite state machine can be converted into an equivalent regular
expression we will then have shown that the language
$L_1 \cap L_2$ is regular.  We will use the \textsc{Fsm}s $F_1$ and $F_2$ to construct $F$.
Assume that
\\[0.2cm]
\hspace*{1.3cm}
$F_1 = \langle Q_1, \Sigma, \delta_1, q_1, A_1 \rangle$ \quad and \quad
$F_2 = \langle Q_2, \Sigma, \delta_2, q_2, A_2 \rangle$
\\[0.2cm]
holds.  We define $F$ as the \blue{generalized Cartesian product} of $F_1$ und $F_2$ as follows:
\\[0.2cm]
\hspace*{1.3cm}
$F := \langle Q_1 \times Q_2, \Sigma, \delta, \pair(q_1,q_2), A_1 \times A_2 \rangle$,
\\[0.2cm]
where the state transition function 
\\[0.2cm]
\hspace*{1.3cm}
 $\delta : (Q_1 \times Q_2) \times \Sigma \rightarrow Q_1 \times Q_2$ 
\\[0.2cm]
is defined as
\\[0.2cm]
\hspace*{1.3cm}
$\delta\bigl( \pair(p_1, p_2), c \bigr) := \bigl\langle\delta_1(p_1,c), \delta_2(p_2,c)\bigr\rangle$.
\\[0.2cm]
Effectively, the \textsc{Fsm} $F$ runs the \textsc{Fsm} $F_1$ and $F_2$ in parallel.  In order to do so, the
states of $F$ are pairs of the form $\pair(p_1,p_2)$ where $p_1$ is a state from $F_1$ and $p_2$ is a state from
$F_2$ and the transition function $\delta$ computes the state that follows on
$\pair(p_1,p_2)$ when a character $c$ is read, by simultaneously computing the next states of $p_1$ and $p_2$
in the \textsc{Fsm}s $F_1$ and $F_2$ when these \textsc{Fsm}s read the character $c$. 
A string $s$ is accepted by $F$ if and only if
both $F_1$ and  $F_2$ accept $s$.  Therefore, the set $A$ of accepting states of the \textsc{Fsm} $F$ is defined as:
\\[0.2cm]
\hspace*{1.3cm}
$A := \bigl\{ \pair(p_1,p_2) \in Q_1 \times Q_2 \mid p_1 \in A_1 \wedge p_2 \in A_2 \bigr\} = A_1 \times A_2$.
\\[0.2cm]
Then for all $s \in \Sigma^*$ we have:
$$
\begin{array}[t]{cl}
                & s \in L(F)                                                           \\[0.1cm]
\Leftrightarrow & \delta(\pair(q_1,q_2), s) \in A                                      \\[0.1cm]
\Leftrightarrow & \langle \delta_1(q_1,s), \delta_2(q_2, s) \rangle \in A_1 \times A_2 \\[0.1cm]
\Leftrightarrow & \delta_1(q_1,s) \in A_1 \wedge  \delta_2(q_2, s) \in A_2             \\[0.1cm]
\Leftrightarrow & s \in L(F_1) \wedge  s \in L(F_2)                                    \\[0.1cm]
\Leftrightarrow & s \in L(F_1) \cap L(F_2)                                             \\[0.1cm]
\Leftrightarrow & s \in L_1 \cap L_2                                                 
\end{array}
$$
Therefore we have shown that
\\[0.2cm]
\hspace*{1.3cm}
 $L(F) = L_1 \cap L_2$ 
\\[0.2cm]
and this completes the proof. \qed

\remarkEng
In principle it would be possible to define a function
\\[0.2cm]
\hspace*{1.3cm}
$\wedge: \textsl{RegExp} \times \textsl{RegExp} \rightarrow \textsl{RegExp}$
\\[0.2cm]
that takes to regular expressions $r_1$ and $r_2$ and returns a regular expression  $r_1 \wedge r_2$ such that
we have
\\[0.2cm]
\hspace*{1.3cm}
$L(r_1 \wedge r_2) = L(r_1) \cap L(r_2)$.
\\[0.2cm]
To compute $r_1 \wedge r_2$ we would first compute non-deterministic \textsc{Fsm}s  $F_1$ and $F_2$ such that
\\[0.2cm]
\hspace*{1.3cm}
$L(F_1) = L(r_1)$ \quad and \quad $L(F_2) = L(r_2)$
\\[0.2cm] 
holds.  Then we would transform the \textsc{Fsm}s $F_1$ and $F_2$ into equivalent deterministic 
\textsc{Fsm}s $\mathtt{det}(F_1)$ and $\mathtt{det}(F_2)$.  After that, we would build
the extended Cartesian product of $\mathtt{det}(F_1)$ and $\mathtt{det}(F_2)$ as shown above. 
Finally, we would convert the \textsc{Fsm} $\mathtt{det}(F_1) \times\mathtt{det}(F_2)$ into an equivalent
regular expression.  However, the resulting regular expression would be absurdly large.
Therefore, it is not practical to implement the function $\wedge$.
\eox


\begin{Proposition}
  If $L$ is a regular language with the alphabet $\Sigma$, then the \blue{complement} \index{complement of a language}
  of $L$, which is defined as the language $\Sigma^* \backslash L$, is regular.
\end{Proposition}

\proofEng
We assume that $r$ is a regular expression describing the language $L$, i.e.~$L=L(r)$. 
We construct a non-deterministic \textsc{Fsm} $F$ such that $L(F) = L(r) = L$.  
We transform this non-deterministic \textsc{Fsm} into the deterministic \textsc{Fsm} $\mathtt{det}(F)$ as discussed
in the previous chapter.
Assume that we have
\\[0.2cm]
\hspace*{1.3cm} $\mathtt{det}(F) = \langle Q, \Sigma, \delta, q_0, A \rangle$.
\\[0.2cm]
We define the deterministic \textsc{Fsm} $\overline{\mathtt{det}(F)}$ as follows:
\\[0.2cm]
\hspace*{1.3cm} $\overline{\mathtt{det}(F)} = \langle Q, \Sigma, \delta, q_0, Q \backslash A \rangle$.
\\[0.2cm]
Then we have
$$
\begin{array}[t]{cl}
                  & w \in L\Bigl(\overline{\mathtt{det}(F)}\Bigr)                      \\[0.2cm]
  \Leftrightarrow & \delta(q_0, w) \in Q \backslash A     \\[0.2cm]
  \Leftrightarrow & \delta(q_0, w) \not\in A \\[0.2cm]
  \Leftrightarrow & w \not\in L\bigl(\mathtt{det}(F)\bigr) \\[0.2cm]
  \Leftrightarrow & w \not\in L(F) \\[0.2cm]
  \Leftrightarrow & w \not\in L(r) \\[0.2cm]
  \Leftrightarrow & w \not\in L \\[0.2cm]
  \Leftrightarrow & w \in \Sigma^* \backslash L 
 \end{array}
$$
This shows that the language $\Sigma^* \backslash L$ is accepted by the \textsc{Fsm} $\overline{\mathtt{det}(F)}$
and hence it is a regular language.
 \qed

\begin{Corollary} \label{kor:mengendif}
  If $L_1$ and $L_2$ are regular languages over the common alphabet $\Sigma$, then the \blue{set difference}
  \index{set difference} $L_1 \backslash L_2$  is a regular language.
\end{Corollary}

\proofEng
A string $w$ is a member of $L_1 \backslash L_2$ iff $w$ is a member of $L_1$
and $w$ is also a member of the complement of $L_2$.  Therefore we have
\\[0.2cm]
\hspace*{1.3cm}
$L_1 \backslash L_2 = L_1 \cap (\Sigma^* \backslash L_2)$,
\\[0.2cm]
The previous proposition shows that for a regular language $L_2$ the complement
$\Sigma^* \backslash L_2$ is also a regular language.  Since the intersection of regular languages is regular,
too, we see that $L_1 \backslash L_2$ is also regular.
\qed
\vspace*{0.3cm}

All in all we have now shown that regular languages are closed under Boolean set operations.

\exerciseEng
Assume $\Sigma$ to be some alphabet.  For a string $s=c_1 c_2 \cdots c_{n-1} c_n \in \Sigma^*$ the
\blue{reversal} \index{reversal of a string}
of $s$ is written $s^R$ and it is defined as
\\[0.2cm]
\hspace*{1.3cm}
$s^R := c_n c_{n-1} \cdots c_2 c_1$.
\\[0.2cm]
For example, if $s = \mathtt{abc}$, then $s^R = \mathtt{cba}$. The reversal $L^R$ of a language \index{reversal of a language}
$L \subseteq \Sigma^*$ is defined as 
\\[0.2cm]
\hspace*{1.3cm}
$L^R := \{ s^R \mid s \in L \}$.
\\[0.2cm]
Next, assume that the language $L \subseteq \Sigma^*$ is regular.  Prove that then $L^R$ is a regular
language, too. \eox

\section{Recognizing Empty Languages \label{section:leer}}
In this section we develop an algorithm that take a deterministic \textsc{Fsm}
\\[0.2cm]
\hspace*{1.3cm}
$F = \langle Q, \Sigma, \delta, q_0, A \rangle$
\\[0.2cm]
as input and checks, whether the language accepted by $F$ is empty, i.e.~it checks whether 
$L(F) = \{\}$.  To this end we interpret the \textsc{Fsm} $F$ as a directed graph.  The nodes of this graph are the
states of the set $Q$ and for two states $q_1$ and
$q_2$ there is an edge  $q_1$ from to $q_2$ iff there exists a character $c \in \Sigma$, such that $\delta(q_1,
c) = q_2$.  
The language $L(F)$ is empty if and only if this graph has no path that starts in the state
$q_0$ and leads to an accepting state.

Therefore, in order to answer the question whether $L(F) = \{\}$ holds, we have to compute the set $R$
of all those states that are \blue{reachable} from the start state $q_0$.  The computation of $R$ can be done
iteratively as follows:
\begin{enumerate}
\item $q_0 \in R$.
\item $p_1 \in R \wedge \delta(p_1,c) = p_2 \;\rightarrow\; p_2 \in R$.

      This last step is repeated until there are no more states that can be added to the set $R$.
\end{enumerate}
Then we have $L(F) = \{\}$ if and only if none of the accepting states is reachable, i.e.~we have
\\[0.2cm]
\hspace*{1.3cm}
$L(F) = \{\} \;\Leftrightarrow\; R \cap A = \{\}$.
\\[0.2cm]
Hence we now have an algorithm for checking whether $L(F) = \{\}$ holds:
We compute the states that are reachable from the start state $q_0$ and then we check whether this set
contains any accepting states.

\remarkEng
If the regular language  $L$ is not specified via an \textsc{Fsm} $F$, but rather is defined
via a regular expression $r$, then there is a simple recursive algorithm for checking whether 
$L(r)$ is empty:
\begin{enumerate}
\item $L(\emptyset) = \{\}$.
\item $L(\varepsilon) \not= \{\}$.
\item $L(c) \not= \{\}$ \quad for all $c \in \Sigma$.
\item $L(r_1 \cdot r_2) = \{\} \;\Leftrightarrow\; L(r_1) = \{\} \vee L(r_2) = \{\}$.
\item $L(r_1 + r_2) = \{\} \;\Leftrightarrow\; L(r_1) = \{\} \wedge L(r_2) = \{\}$.
\item $L(r^*) \not= \{\}$. \eox
\end{enumerate}


\section{Equivalence of Regular Expressions}
In Chapter \ref{chapter:regular-expressions} we had defined two regular expressions $r_1$ and $r_2$ to be \blue{equivalent} 
(written $r_1 \doteq r_2$), if the languages specified by $r_1$ and $r_2$ are identical:
\\[0.2cm]
\hspace*{1.3cm}
$r_1 \doteq r_2 \stackrel{\mbox{\scriptsize def}}{\Longleftrightarrow} L(r_1) = L(r_2)$. 
\\[0.2cm]
In this section, we present an algorithm that receives two regular expressions $r_1$ and $r_2$ as input and then
checks whether $r_1 \doteq r_2$ holds. 


\begin{Theorem}
  If $r_1$ and $r_2$ are regular expressions, then the question whether $r_1 \doteq r_2$ holds is decidable.
\end{Theorem}

\proofEng
We present an algorithm that decides, whether $L(r_1) = L(r_2)$.  First, we observe that the sets
$L(r_1)$ and $L(r_2)$ are identical iff the set differences $L(r_2) \backslash L(r_1)$ and $L(r_1) \backslash L(r_2)$
are both empty:
\begin{eqnarray*}
                  L(r_1) = L(r_2) 
&\Leftrightarrow& L(r_1) \subseteq L(r_2)         \;\wedge\; L(r_2) \subseteq L(r_1)          \\
&\Leftrightarrow& L(r_1) \backslash L(r_2) = \{\} \;\wedge\; L(r_2) \backslash L(r_1) = \{\}  
\end{eqnarray*}
Next, assume that $F_1$ and $F_2$ are deterministic \textsc{Fsms} such that
\\[0.2cm]
\hspace*{1.3cm}
$L(F_1) = L(r_1)$ \quad and \quad $L(F_2) = L(r_2)$
\\[0.2cm]
holds.  We have seen in Chapter \ref{chapter:finit-state-machines.tex} how $F_1$ and $F_2$ can be
constructed from $r_1$ and $r_2$. According to the corollary \ref{kor:mengendif} the languages
$L(r_1) \backslash L(r_2)$ and $L(r_2) \backslash L(r_1)$ are regular and we have seen how to
construct \textsc{Fsm}s $F_{1,2}$ and $F_{2,1}$ such that
\\[0.2cm]
\hspace*{1.3cm}
$L(r_1) \backslash L(r_2) = L(F_{1,2})$ \quad and \quad $L(r_2) \backslash L(r_1) = L(F_{2,1})$ 
\\[0.2cm]
holds.  Hence we have
\\[0.2cm]
\hspace*{1.3cm}
$r_1 \doteq r_2 \;\Leftrightarrow\; L(F_{1,2}) = \{\} \wedge  L(F_{2,1}) = \{\}$
\\[0.2cm]
and according to Section \ref{section:leer} this question is decidable by checking whether any of
the accepting states of $F_{1,2}$ or $F_{2,1}$ are reachable from the start state.
\qed

\remarkEng
The Jupyter notebook \texttt{Equivalence}, which is available at
\\[0.2cm]
\hspace*{0.8cm}
\href{https://github.com/karlstroetmann/Formal-Languages/blob/master/Python/Equivalence.ipynb}{\texttt{https://github.com/karlstroetmann/Formal-Languages/blob/master/Python/Equivalence.ipynb}}
\\[0.2cm]
implements the theory discussed in this section.

\section{Limits of Regular Languages}
In this section we present a theorem that can be used to show that certain languages are
\underline{not} regular.  This theorem is know as the 
\href{https://en.wikipedia.org/wiki/Pumping_lemma_for_regular_languages}{\blue{pumping lemma for regular languages}}.

\begin{Theorem}[Pumping Lemma for Regular Languages] \lb
  Assume $L$ is a regular language.  Then there exists a natural number $n \in \mathbb{N}$ such that
  every string $s \in L$ that has a length of at least $n$ can be split into three substrings $u$,
  $v$, and $w$ such that the following holds:
  \begin{enumerate}
  \item $s= uvw$,
  \item $v \not= \varepsilon$,
  \item $|uv| \leq n$,
  \item $\forall h \in \mathbb{N}_0: uv^hw \in L$.
  \end{enumerate}
  This theorem can be written as a single formula:  If $L$ is a regular language, then 
  \\[0.2cm]
  \hspace*{1.3cm}
  $\exists n \in \mathbb{N}: \forall s \in L : \Bigl(|s| \geq n \rightarrow \exists u,v,w\in \Sigma^* :
   s = uvw \wedge v \not= \varepsilon \wedge |uv| \leq n \wedge 
    \forall h \in \mathbb{N}_0: uv^h w \in L
   \Bigr)
  $.
\end{Theorem}

\proofEng
As $L$ is a regular language, there exists a deterministic \textsc{Fsm}
\\[0.2cm]
\hspace*{1.3cm}
$F = \langle Q, \Sigma, \delta, q_0, A \rangle$,
\\[0.2cm]
such that $L = L(F)$.  The number $n$ whose existence is claimed in the Pumping Lemma is defined as
the number of states of $F$: 
\\[0.2cm]
\hspace*{1.3cm}
$n := \textsl{card}(Q)$.
\\[0.2cm]
Next, assume a string $s \in L$ is given such that $|s| \geq n$.  Then there are $m := |w|$
characters $c_i$ such that
\\[0.2cm]
\hspace*{1.3cm}
$s = c_1 c_2 \cdots c_m$.
\\[0.2cm]
Since $|s| \geq n$ we have $m \geq n$.  On reading the characters $c_i$ the \textsc{Fsm} changes its
states as follows:
\\[0.2cm]
\hspace*{1.3cm}
$q_0 \stackrel{c_1}{\longmapsto} q_1 \stackrel{c_2}{\longmapsto} q_2 \stackrel{c_3}{\longmapsto} \cdots \stackrel{c_m}{\longmapsto} q_m$
\\[0.2cm]
and since we have  $s \in L$ we conclude that  $q_m$ must be an accepting state, i.e.~$q_m \in A$.
As $m \geq n$ and $n$ is the total number of states of $F$, not all of the states 
\\[0.2cm]
\hspace*{1.3cm}
$q_0$, $q_1$, $q_2$, $\cdots$, $q_m$
\\[0.2cm]
can be different.
Because of
\\[0.2cm]
\hspace*{1.3cm}
$\textsl{card}\bigl(\{0,1,\cdots,n\}\bigr) = n+1$
\\[0.2cm]
we know, that even in the list
\\[0.2cm]
\hspace*{1.3cm}
$[q_0,q_1,q_2,\cdots, q_{n}]$
\\[0.2cm]
at least one state has to occur at least twice.  Hence there are $k, l \in \{0,\cdots,n\}$ such that
\\[0.2cm]
\hspace*{1.3cm}
$q_k = q_l \wedge k < l$.
\\[0.2cm]
Next, we define the strings $u$, $v$, and $w$ as follows:
\\[0.2cm]
\hspace*{1.3cm}
$u := c_1 \cdots c_k$, \quad $v := c_{k+1} \cdots c_l$, \quad and \quad $w := c_{l+1} \cdots c_{m}$.
\\[0.2cm]
As $k < l$ we have that $v \not= \varepsilon$ and $l \leq n$ implies $|uv| \leq n$.
Furthermore, we have the following:
\begin{enumerate}
\item Reading the string $u$ changes the state of the \textsc{Fsm} $F$ from the start state $q_0$ to
      the state $q_k$, we have
      \begin{equation}
        \label{eq:pumping1}
        q_0 \stackrel{u}{\longmapsto} q_k.    
      \end{equation}
\item Reading the string $v$ changes the state of the \textsc{Fsm} $F$ from the state $q_k$ to the
      state $q_l$.  As we have $q_l = q_k$, this implies
      \begin{equation}
        \label{eq:pumping2}
      q_k \stackrel{v}{\longmapsto} q_k.        
      \end{equation}
\item Reading the string $w$ changes the state of the \textsc{Fsm} $F$ from the state  $q_l = q_k$
      to the accepting state $q_m$:
      \begin{equation}
        \label{eq:pumping3}
        q_k \stackrel{w}{\longmapsto} q_m.        
      \end{equation}
\end{enumerate}
From $q_k \stackrel{v}{\longmapsto} q_k$ we conclude
\\[0.2cm]
\hspace*{1.3cm}
$q_k \stackrel{v}{\longmapsto} q_k \stackrel{v}{\longmapsto} q_k$, \quad hence \quad $q_k \stackrel{v^2}{\longmapsto} q_k$.
\\[0.2cm]
As we can repeat reading $v$ in state $q_k$ any number of times, we have
\begin{equation}
  \label{eq:pumping4}
  q_k \stackrel{v^h}{\longmapsto} q_k  \quad \mbox{for all $h \in \mathbb{N}_0$.}
\end{equation}
Combining the equations (\ref{eq:pumping1}), (\ref{eq:pumping3}), and (\ref{eq:pumping4})  we have
\\[0.2cm]
\hspace*{1.3cm}
$q_0 \stackrel{u}{\longmapsto} q_k \stackrel{v^h}{\longmapsto} q_k \stackrel{w}{\longmapsto} q_m$.
\\[0.2cm]
This can be condensed to
\\[0.2cm]
\hspace*{1.3cm}
$q_0 \stackrel{uv^hw}{\longmapsto} q_m$
\\[0.2cm]
and since the state $q_m$ is an accepting state we conclude that $uv^hw \in L$ holds for any $h \in \mathbb{N}_0$. \qed



\begin{Proposition}
  The alphabet  $\Sigma$ is defined as $\Sigma = \{ \quoted{a}, \quoted{b} \}$.
  Define the language $L$ as the set of all strings of the form $\mathtt{a}^k\mathtt{b}^k$ where $k$
  is some natural number:
  \\[0.2cm]
  \hspace*{1.3cm}
  $L = \bigl\{ \mathtt{a}^k\mathtt{b}^k \mid k \in \mathbb{N} \bigr\}$.
  \\[0.2cm]
  Then the language  $L$ is not regular.
\end{Proposition}

\proofEng
The proof is a proof by contradiction. We assume that $L$ is a regular language.  According to the
Pumping Lemma there exists a fixed natural number $n$ such that every $s \in L$ that satisfies  $|s|
\geq n$ can be written as
\\[0.2cm]
\hspace*{1.3cm}
$s = uvw$
\\[0.2cm]
such that
\\[0.2cm]
\hspace*{1.3cm}
$|uv| \leq n$, \quad $v \not= \varepsilon$, \quad and \quad $\forall h \in \mathbb{N}_0: uv^h w \in L$
\\[0.2cm]
holds.  Let us define the string $s$ as
\\[0.2cm]
\hspace*{1.3cm}
$s := \mathtt{a}^{n} \mathtt{b}^{n}$.
\\[0.2cm]
Obviously we have $|s| = 2 \cdot n \geq n$.  Hence there are strings $u$, $v$, and $w$
such that 
\\[0.2cm]
\hspace*{1.3cm}
$\mathtt{a}^{n}\mathtt{b}^{n} = uvw$, \quad $|uv| \leq n$, \quad $v \not= \varepsilon$, 
\quad and \quad $\forall h \in \mathbb{N}_0: uv^h w \in L$.
\\[0.2cm]
As $|uv| \leq n$, the string $uv$ is a prefix not only of $s$ but even of $\mathtt{a}^n$. Therefore,
and since $v \not= \varepsilon$ we know that the string $v$ must have the form
\\[0.2cm]
\hspace*{1.3cm}
$v = \mathtt{a}^k$ \quad for some $k \in \mathbb{N}$.
\\[0.2cm]
If we take the formula $\forall h \in \mathbb{N}_0: uv^h w \in L$ and set  $h:=0$, we conclude that
\begin{equation}
  \label{eq:pumping5}
 uw \in L. 
\end{equation}
In order to facilitate our argument, we define the function
\\[0.2cm]
\hspace*{1.3cm}
$\textsl{count}: \Sigma^* \times \Sigma \rightarrow \mathbb{N}_0$.
\\[0.2cm]
Given a  string $t$ and a character $c$ the function $\textsl{count}(t,c)$ counts how often the
character $c$ occurs in the string $t$.  For the language  $L$ we have
\\[0.2cm]
\hspace*{1.3cm}
$t \in L \Rightarrow \textsl{count}(t,\squoted{a}) = \textsl{count}(t, \squoted{b})$. 
\\[0.2cm]
On one hand we have:
\[  
\begin{array}{lcl}
\textsl{count}(uw,\squoted{a}) & = & \textsl{count}(uvw,\squoted{a}) - \textsl{count}(v,\squoted{a}) \\
 & = & \textsl{count}(s,\squoted{a}) - \textsl{count}(v,\squoted{a}) \\
 & = & \textsl{count}(\mathtt{a}^n\mathtt{b}^n,\squoted{a}) - \textsl{count}(\mathtt{a}^k,\squoted{a}) \\
 & = & n - k  \\
 & < & n   \\
\end{array}
\]
But on the other hand we have
\[  
\begin{array}{lcl}
\textsl{count}(uw,\squoted{b}) & = & \textsl{count}(uvw,\squoted{b}) - \textsl{count}(v,\squoted{b}) \\
                               & = & \textsl{count}(s,\squoted{b}) - \textsl{count}(v,\squoted{b}) \\
 & = & \textsl{count}(\mathtt{a}^n\mathtt{b}^n,\squoted{b}) - \textsl{count}(\mathtt{a}^k,\squoted{b}) \\
                               & = & n  - 0\\
                               & = & n  
\end{array}
\]
Therefore, we have
\\[0.2cm]
\hspace*{1.3cm}
$\textsl{count}(uw,\squoted{a}) < \textsl{count}(uw,\squoted{b})$
\\[0.2cm]
and this shows that the string $uw$ is not a member of the language $L$ because for all strings in $L$ 
the same number of occurrences of the character ``\texttt{a}'' is the same as the number of
occurrences of the character ``\texttt{b}''.  This contradiction shows that the language $L$ cannot
be regular.
\qed

\remark
The previous proposition shows that the expressive power of regular languages is quite weak.
We could easily adapt the previous proposition to show that the language
\\[0.2cm]
\hspace*{1.3cm}
$\bigl\{ \mathtt{(}^n \mathtt{)}^n \mid n \in \mathbb{N} \bigr\}$
\\[0.2cm]
is not regular.  Hence, regular expressions are unable to check even such simple questions as to
whether the parentheses in an expressions are balanced.  Therefore, the concept of regular
expressions is not strong enough to describe the syntax of a programming language.
The next chapter introduces the notion of \blue{context-free languages}.  These languages
are powerful enough to describe modern programming languages. 

\exerciseEng
The language  $L_{\mathrm{square}}$ is the set of all strings of the form $\mathtt{a}^n$ where $n$
is a square, we have
\\[0.2cm]
\hspace*{1.3cm}
$L_{\mathrm{square}} = \bigl\{ a^{m} \mid \exists k \in \mathbb{N}_0: m = k^2 \bigr\}$
\\[0.2cm]
Prove that the language  $L_{\mathrm{square}}$ is not a regular language.
\eox
\vspace*{0.1cm}

\noindent
\textbf{Hint}:  When looking for a counter example, you should try to set $h:=2$.


\solution
Wir f\"uhren den Beweis indirekt und nehmen an, dass $L_{\mathrm{square}}$ regul\"ar
w\"are.  Nach dem Pumping-Lemma gibt es dann eine positive nat\"urliche Zahl $n$ (dies war die Anzahl
der Zust\"ande des deterministischen Automaten, der die Sprache erkennt), so dass sich jeder String
$s \in L_{\mathrm{square}}$ mit $|s| \geq n$ in drei Teilstrings $u$, $v$ und $w$ aufspalten l\"asst, so dass gilt:
\begin{enumerate}
\item $s = uvw$,
\item $|uv| \leq n$,
\item $v \not= \varepsilon$,
\item $\forall h \in \mathbb{N}_0: uv^hw \in L_{\mathrm{square}}$. 
\end{enumerate} 
Wir betrachten nun den String $s = a^{n^2}$.  F\"ur die L\"ange dieses Strings gilt offenbar
\[ |s| = \big| a^{n^2} \big| = n^2 \geq n. \]
Also gibt es eine Aufspaltung von $s$ der Form $s = uvw$ mit den oben angegebenen Eigenschaften.
Da $a$ der einzige Buchstabe ist, der in $s$ vorkommt, k\"onnen in $u$, $v$ und $w$ auch keine anderen
Buchstaben vorkommen und es muss nat\"urliche Zahlen $x$, $y$ und $z$ geben, so dass 
\[ u = a^x,\; v = a^y\; \mbox{und}\; w = a^z \]
gilt.  Wir untersuchen, welche Konzequenzen sich daraus f\"ur die Zahlen $x$, $y$ und $z$ ergeben.
\begin{enumerate}
\item Die Zerlegung $s = uvw$ schreibt sich als $a^{n^2} = a^xa^ya^z$ und daraus folgt
      \begin{equation}
        \label{eq:e1}
         n^2 = x + y + z.     
      \end{equation}
\item Die Ungleichung $|uv| \leq n$ ist jetzt \"aquivalent zu $x +y \leq n$, woraus 
      \begin{equation}
        \label{eq:e2}
        y \leq n
      \end{equation}
      folgt.
\item Die Bedingung $v \not= \varepsilon$ liefert
      \begin{equation}
        \label{eq:e3}
        y > 0.
      \end{equation}
\item Aus der Formel $\forall h \in \mathbb{N}_0: uv^hw \in L_{\mathrm{square}}$ folgt
      \begin{equation}
        \label{eq:e4}
        \forall h \in \mathbb{N}_0: a^xa^{y\cdot h}a^z \in L_{\mathrm{square}}. 
      \end{equation}
\end{enumerate}
Die letzte Gleichung muss insbesondere auch f\"ur den Wert $h=2$ gelten:
\[ a^xa^{y\cdot 2}a^z \in L_{\mathrm{square}}.  \]
Nach Definition der Sprache $L_{\mathrm{square}}$ gibt es dann eine nat\"urliche Zahl
$k$, so dass gilt
\begin{equation}
  \label{eq:e5}
  x + 2\cdot y + z = k^2
\end{equation}
Addieren wir in Gleichung (\ref{eq:e1}) auf beiden Seiten $y$, so erhalten wir insgesamt
\[ n^2 + y = x + 2\cdot y + z = k^2. \]
Wegen $y > 0$ folgt daraus 
\begin{equation}
  \label{eq:e6}
  n < k.    
\end{equation}
Andererseits haben wir
\[ 
\begin{array}[t]{lcll}
 k^2  & =    & x + 2 \cdot y + z       & \mbox{nach Gleichung (\ref{eq:e5}})   \\
      & =    & x + y + z + y           & \mbox{elementare Umformung}           \\
      & \leq & x + y + z + n           & \mbox{nach Ungleichung (\ref{eq:e2}}) \\
      & =    & n^2 + n                 & \mbox{nach Gleichung (\ref{eq:e1}})   \\
      & <    & n^2 + 2 \cdot n + 1     & \mbox{da $n+1 > 0$}                   \\ 
      & =    & (n + 1)^2               & \mbox{elementare Umformung}           \\ 
\end{array}
\]
Damit haben wir insgesamt  $k^2 < (n+1)^2$ gezeigt und das impliziert
\begin{equation}
  \label{eq:e7}
  k < n+1.
\end{equation}
Zusammen mit Ungleichung (\ref{eq:e6}) liefert Ungleichung (\ref{eq:e7}) nun die Ungleichungs-Kette
\[ n < k < n + 1. \]
Da andererseits $k$ eine nat\"urliche Zahl sein muss und $n$ ebenfalls eine nat\"urliche Zahl ist,
haben wir jetzt einen Widerspruch, denn zwischen $n$ und $n+1$ gibt es keine nat\"urliche Zahl.
\qed
\pagebreak

\renewcommand{\labelenumi}{(\alph{enumi})}

\exerciseEngStar
The language $L$ is defined as
\\[0.2cm]
\hspace*{1.3cm}
$L := \{ \mathtt{a}^m \mathtt{b}^n \mathtt{c}^n \mid m,n \in \mathbb{N} \} \cup 
      \{ \mathtt{b}^m \mathtt{c}^n \mid m,n \in \mathbb{N} \} 
$.
\begin{enumerate}
\item Prove that $L$ is not regular.
\item Prove that $L$ satisfies the pumping lemma.  \eox
\end{enumerate}

\renewcommand{\labelenumi}{\arabic{enumi}.}

\exerciseEng
Define $\Sigma := \{\mathtt{a},\mathtt{b}\}$.  
Prove that the language
\\[0.2cm]
\hspace*{1.3cm}
$L := \bigl\{ \mathtt{a}^p \mid \mbox{$p$ is a prime number} \bigr\}$
\\[0.2cm]
is not regular.  \eox
\vspace{0.3cm}

\noindent
\textbf{Beweis}:
Wir f\"uhren den Beweis indirekt und nehmen an, $L$ w\"are regul\"ar.  Nach
dem Pumping-Lemma gibt es dann eine Zahl $n$, so dass es f\"ur alle Strings $s \in L$, 
deren L\"ange gr\"o{\ss}er-gleich $n$ ist, eine Zerlegung
\\[0.2cm]
\hspace*{1.3cm}
$s = uvw$
\\[0.2cm]
mit den folgenden drei Eigenschaften gibt:
\begin{enumerate}
\item $v \not= \varepsilon$, 
\item $|uv| \leq n$ \quad und
\item $\forall h \in \mathbb{N}_0: u v^h w \in L$.
\end{enumerate}
Wir w\"ahlen nun eine Primzahl $p$, die gr\"o{\ss}er-gleich  $n + 2$ ist und setzen $s = \mathtt{a}^p$.
Dann gilt $|s| = p \geq n$ und die Voraussetzung des Pumping-Lemmas ist erf\"ullt.
Wir finden also eine Zerlegung von $\mathtt{a}^p$ der Form
\\[0.2cm]
\hspace*{1.3cm}
$\mathtt{a}^p = uvw$ 
\\[0.2cm]
mit den oben angegebenen Eigenschaften.
Aufgrund der Gleichung $s = uvw$ k\"onnen die Teilstrings $u$, $v$ und $w$ nur aus dem
Buchstaben ``\texttt{a}'' bestehen.  Also gibt es nat\"urliche Zahlen $x$, $y$, und
$z$ so dass gilt:
\\[0.2cm]
\hspace*{1.3cm}
$u = \mathtt{a}^x$, \quad $v = \mathtt{a}^y$ \quad und \quad $w = \mathtt{a}^z$.
\\[0.2cm]
F\"ur  $x$, $y$ und $z$ gilt dann Folgendes:
\begin{enumerate}
\item $x + y + z = p$,
\item $y \not= 0$,
\item $x + y \leq n$,
\item $\forall h \in \mathbb{N}_0: x + h \cdot y + z \in \mathbb{P}$.
\end{enumerate}
Setzen wir in der letzten Gleichung f\"ur $h$ den Wert $(x + z)$ ein, so erhalten wir
\\[0.2cm]
\hspace*{1.3cm}
$x + (x + z)\cdot y + z \in P$.
\\[0.2cm]
Wegen $x + (x + z)\cdot y + z = (x + z) \cdot (1 + y)$ h\"atten wir dann
\\[0.2cm]
\hspace*{1.3cm}
$(x + z) \cdot (1 + y) \in \mathbb{P}$.
\\[0.2cm]
Das kann aber nicht sein, denn wegen $y > 0$ ist der Faktor $1 + y$ von 1
verschieden und wegen $x + y \leq n$ und $x + y + z = p$ und $p \geq n + 2$ wissen wir, dass
$z \geq 2$ ist, so dass auch der Faktor $(x + z)$ von 1 verschieden ist.  Damit kann das Produkt
$(x + z) \cdot (1 + y)$ aber keine Primzahl mehr sein und wir haben einen Widerspruch zu der
Annahme, dass $L$ regul\"ar ist. \qed


\exercise
Die Sprache $L_{\mathrm{power}}$ beinhaltet alle W\"orter der Form $\mathtt{a}^n$ f\"ur die $n$ eine
Zweier-Potenz ist, es gilt also
\\[0.2cm]
\hspace*{1.3cm}
$L_{\mathrm{power}} = \bigl\{ \mathtt{a}^{2^k} \mid k \in \mathbb{N}_0 \bigr\}$
\\[0.2cm]
Zeigen Sie mit Hilfe des Pumping-Lemmas, dass die Sprache $L_{\mathrm{power}}$ keine regul\"are Sprache ist.
\eox

\exercise
F\"ur zwei nat\"urliche Zahlen $k$ und $l$ bezeichne der Ausdruck $\mathtt{ggt}(k, l)$ den gr\"o{\ss}ten
gemeinsamen Teiler von $k$ und $l$.  Wir definieren die Sprache $L_{\mathrm{ggt}}$ als
\\[0.2cm]
\hspace*{1.3cm}
$L_{\mathrm{ggt}} := \bigl\{ \mathtt{a}^k\mathtt{b}^l \mid k \in \mathbb{N} \wedge l \in \mathbb{N} \wedge \mathtt{ggt}(k, l) = 1 \bigr\}$.
\\[0.2cm]
Zeigen Sie, dass die Sprache $L_{\mathrm{ggt}}$ keine regul\"are Sprache ist.
\vspace{0.2cm}

\noindent
\textbf{Hinweis}:  Nutzen Sie aus, dass regul\"are Sprachen unter Komplement-Bildung abgeschlossen sind.
\eox


\paragraph{Historical Remark}
The pumping lemma is a special case of a general theorem that has been proved by Bar-Hillel, Perles and
Shamir in 1961 \cite{barhillel:1961}.


%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "formal-languages.tex"
%%% End: 

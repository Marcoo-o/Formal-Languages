\chapter{Introduction and Motivation}
This lecture explores the theory of formal languages and delves into various applications, with a focus on the
development of scanners, parsers, interpreters, and compilers. We also introduce several specialized tools
designed to aid in the creation of these components, specifically: 
\begin{enumerate}
\item \blue{\textsc{Ply}}: \index{\textsc{Ply}} A tool for generating parsers using the programming language
      \textsl{Python}. 
\item \blue{\textsc{Antlr}}: \index{\textsc{Antlr}} A versatile tool capable of generating parsers for multiple
       programming languages, including \textsl{Python} and \textsl{Java}. 
\end{enumerate}
These tools are categorized as \blue{program generators}. They accept language descriptions as input and output
parsers accordingly. 

\section{Basic Definitions}
The cornerstone of this lecture is the concept of a \href{http://en.wikipedia.org/wiki/Formal_language}{\emph{formal language}}, \index{formal language} essentially defined as a set of strings characterized by precise mathematical criteria. To establish this concept, we first introduce some foundational definitions.

\begin{Definition}[Alphabet]
An \blue{alphabet} \( \Sigma \) \index{alphabet} is a finite, non-empty set of \blue{characters}:
\\[0.2cm]
\hspace*{1.3cm}
\( \Sigma = \{ c_1, \cdots, c_n \} \).
\\[0.2cm]
The term \blue{symbol} \index{symbol} is occasionally used interchangeably with character.
\qed
\end{Definition}

\examplesEng
\begin{enumerate}[(a)]
\item \( \Sigma = \{ 0, 1 \} \) is an alphabet suitable for representing binary numbers.
\item \( \Sigma = \{ \mathtt{a}, \cdots, \mathtt{z}, \mathtt{A}, \cdots, \mathtt{Z} \} \) comprises the alphabet for the English language.
\item \( \Sigma_{\textsc{\scriptsize Ascii}} = \{ 0, 1, \cdots, 127 \} \) is known as the
      \href{http://en.wikipedia.org/wiki/ASCII}{\textsc{Ascii}-Alphabet}. \index{\textsc{Ascii}-Alphabet} Here,
      numbers correspond to letters, digits, punctuation marks, and control characters. For instance, the set
      \( \{ 65, \cdots, 90 \} \) maps to the letters \( \{ \mathtt{A}, \cdots, \mathtt{Z} \} \).
\item \( \Sigma_{\textsc{\scriptsize Unicode}} = \{ 0, 1, \cdots, 1\,114\,111 \} \) represents the
      \href{https://en.wikipedia.org/wiki/Unicode}{\textsc{Unicode}-Alphabet}. \index{\textsc{Unicode}-Alphabet}
      This extensive set accommodates a wide array of characters, including various scripts, symbols, and even emojis. 
\eox
\end{enumerate}

\begin{Definition}[Strings]
For a given alphabet \( \Sigma \), a \blue{string} \index{string} is a sequence of characters selected from \( \Sigma \). In formal language theory, these sequences are written without brackets or separating commas. Thus, for \( c_1, \cdots, c_n \in \Sigma \), we write
\\[0.2cm]
\hspace*{1.3cm}
\( w = c_1 \cdots c_n \) \quad instead of \quad \( w = [c_1, \cdots, c_n] \).
\\[0.2cm]
The empty string is represented by \( \lambda \), \index{\( \lambda \)} so \( \lambda = \texttt{""} \).
The set of all possible strings formed from the alphabet \( \Sigma \) is denoted as \( \Sigma^* \). \index{\( \Sigma^* \)} Strings are often enclosed in quotation marks for emphasis.
\qed
\end{Definition}

\examplesEng
\begin{enumerate}[(a)]
\item Let \( \Sigma = \{0, 1\} \). Defining
      \\[0.2cm]
      \hspace*{1.3cm}
      \( w_1 := \mathtt{"01110"} \) and \( w_2 := \mathtt{"11001"} \),
      \\[0.2cm]
      both \( w_1 \) and \( w_2 \) are strings over \( \Sigma \). Hence, we can state:
      \\[0.2cm]
      \hspace*{1.3cm}
      \( w_1 \in \Sigma^* \) and \( w_2 \in \Sigma^* \).
\item Consider \( \Sigma = \{\mathtt{a}, \cdots, \mathtt{z}\} \). With
      \\[0.2cm]
      \hspace*{1.3cm}
      \( w := \mathtt{"example"} \),
      \\[0.2cm]
      it follows that \( w \in \Sigma^* \). \eox
\end{enumerate}

The \emph{length} of a string \( w \) is denoted by \( |w| \) and represents the number of characters in \( w
\).\index{length of a string}  
We employ \blue{array notation} for character extraction: given a string \( w \) and a natural number
\( i \leq |w| \), \( w[i] \) specifies the \( i \)-th character in \( w \). Character counting starts at 0, adhering to
conventions in modern programming languages like \texttt{C}, \textsl{Java}, and \textsl{Python}. 

Next, we introduce the concept of \blue{concatenation} \index{concatenation} of two strings \( w_1 \) and
\(w_2 \). Concatenation results in a new string \( w \) formed by appending \( w_2 \) to \( w_1 \). It is
represented as \( w_1 \cdot w_2 \) or, more succinctly, as \( w_1w_2 \). 

\vspace*{0.3cm}

\exampleEng
For \( \Sigma = \{\mathtt{0}, \mathtt{1}\} \) and \( w_1 = \mathtt{"01"} \) and \( w_2 = \mathtt{"10"} \), the concatenated strings are:
\\[0.2cm]
\hspace*{1.3cm}
\( w_1 \cdot w_2 = \mathtt{"0110"} \) and \( w_2 \cdot w_1 = \mathtt{"1001"} \). \eox

\begin{Definition}[Formal Language] \hspace*{\fill} \linebreak
Given an alphabet \( \Sigma \), a subset \( L \subseteq \Sigma^* \) is called a \blue{formal language} if it is \emph{precisely defined}. \index{formal language} \qed
\end{Definition}

You may wonder what it means for a subset to be \emph{precisely defined}. The criterion is the unambiguous characterization of the subset \( L \), such that it's clear whether a given string belongs to \( L \) or not. For instance, English doesn't qualify as a formal language because it lacks a precise rule set for valid sentences.

This initial definition is intentionally broad. As we progress through the lecture, we will explore specialized versions, most notably \href{http://en.wikipedia.org/wiki/Regular_language}{regular languages} \index{regular language} and \href{http://en.wikipedia.org/wiki/Context-free_language}{context-free languages}. \index{context-free language} These are particularly relevant in computer science.

\examplesEng
\begin{enumerate}
\item Assume that $\Sigma = \{\mathtt{0},\mathtt{1}\}$.  Define
      \\[0.2cm]
      \hspace*{1.3cm}
      $L_\mathbb{N} = \{ \mathtt{1} \cdot w \mid w \in \Sigma^* \} \cup \{ \mathtt{0} \}$
      \\[0.2cm]
      Then $L_\mathbb{N}$ is the language consisting of all strings that can be interpreted as
      natural numbers given in binary notation.  The language contains all strings from $\Sigma^*$  that start with 
      the character \texttt{1} as well as the string \texttt{0}, which only contains the character
      \texttt{0}.  For example, we have
      \\[0.2cm]
      \hspace*{1.3cm}
      $\mathtt{\symbol{34}100\symbol{34}} \in L_\mathbb{N}$, \quad but \quad $\mathtt{\symbol{34}010\symbol{34}} \not\in L_\mathbb{N}$.
      \\[0.2cm]
      Let us define a function 
      \\[0.2cm]
      \hspace*{1.3cm}
      $\textsl{value}: L_\mathbb{N} \rightarrow \mathbb{N}$
      \\[0.2cm]
      on the set $L_\mathbb{N}$.  We define $\textsl{value}(w)$ by induction on the length of $w$.
      We call $\textsl{value}(w)$ the \blue{interpretation} of $w$.  The idea is that
      $\textsl{value}(w)$ computes the number represented by the string $w$:
      \begin{enumerate}
      \item $\textsl{value}(\mathtt{0}) = 0$, $\textsl{value}(1) = 1$,
      \item $|w| > 0 \rightarrow \textsl{value}(w\mathtt{0}) = 2 \cdot \textsl{value}(w)   $,
      \item $|w| > 0 \rightarrow \textsl{value}(w\mathtt{1}) = 2 \cdot \textsl{value}(w) + 1$.
      \end{enumerate}
\item Again we have $\Sigma = \{0,1\}$. Define the language $L_\mathbb{P}$
      to be the set of all strings from $L_\mathbb{N}$ that are prime numbers:
      \\[0.2cm]
      \hspace*{1.3cm}
      $L_\mathbb{P} := \{ w \in L_\mathbb{N} \mid \textsl{value}(w) \in \mathbb{P} \}$
      \\[0.2cm]
      Here, $\mathbb{P}$ denotes the set of \blue{prime numbers}, \index{prime number} which is the set of all natural
      numbers $p$ bigger than $1$ that have no divisor other than $1$ or $p$:
      \\[0.2cm]
      \hspace*{1.3cm}
      $\mathbb{P} = \bigl\{ p \in \mathbb{N} \;\big|\; \{ t \in \mathbb{N} \mid \exists k \in
      \mathbb{N} : k \cdot t = p \} = \{1, p\} \bigr\}$.
\item Define $\Sigma_{\textsc{\scriptsize Ascii}} = \{ 0, \cdots, 127\}$.  Furthermore, define $L_C$
      as the set of all strings of the form
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{char* $f$(char* $x$) \{ $\cdots$ \}}
      \\[0.2cm]
      that are, furthermore, valid \texttt{C} function definitions.
      Therefore,  $L_C$ contains all those strings that can be interpreted as a \texttt{C} function $f$
      such that $f$ takes a single argument which is a string and returns a value which is also a
      string.
\item Define $\Sigma := \Sigma_{\textsc{\scriptsize Ascii}} \cup \{\dag\}$, where
      $\mathtt{\dag}$ is some new symbol that is different from all symbols in
      $\Sigma_{\textsc{\scriptsize Ascii}}$.
      The \blue{universal language} \index{universal language} $L_u$ is the set of all strings of the form
      \\[0.2cm]
      \hspace*{1.3cm}
      $p$\dag$x$\dag$y$
      \\[0.2cm]
      such that
      \begin{enumerate}
      \item $p \in L_C$,
      \item $x,y \in \Sigma_{\textsc{Ascii}}^*$,
      \item if $f$ is the function that is defined by $p$, then $f(x)$ yields the result $y$.
            \eox
      \end{enumerate}
    \end{enumerate}

The above examples illustrate the expansive scope of what can be considered a formal language. While it's
straightforward to identify strings in \( L_\mathbb{N} \), it becomes substantially more challenging for
languages like \( L_\mathbb{P} \) or \( L_C \). Moreover, owing to the
\href{https://en.wikipedia.org/wiki/Halting_problem}{halting problem} being undecidable, no algorithm can
definitively determine membership in \( L_u \). Nevertheless, \( L_u \) is \blue{semi-decidable}: if a string
\( w \) belongs to \( L_u \), we can establish this fact.  

\section{Overview}
The aim of this lecture is to cover a series of interconnected topics. While I will introduce some terms that may not be immediately clear, rest assured that these will be elaborated upon as the lecture progresses. The lecture is structured into three main parts:

\begin{enumerate}
\item The first part delves into the theory of \blue{regular languages}.
  \begin{enumerate}[(a)]
  \item We begin with an exploration of \blue{regular expressions}. After formally defining this term, we will discuss its applications in \textsl{Python}.
  \item We then demonstrate how the \blue{\textsc{Ply}} tool can be utilized to create \blue{scanners}.
  \item Subsequently, we examine the implementation of regular expressions via \blue{finite state machines}.
  \item A discussion on how to verify the \blue{equivalence} of regular expressions follows.
  \item We conclude this section by discussing the limitations of regular languages, focusing particularly on the \blue{Pumping Lemma}.
  \end{enumerate}
  
\item The second part is centered on \blue{context-free languages}, which are instrumental in describing the syntax of programming languages.
  \begin{enumerate}[(a)]
  \item We first introduce \blue{context-free grammars}, which are employed to define context-free languages.
  \item Next, we talk about parser generators, specifically \blue{\textsc{Antlr}} and \blue{\textsc{Ply}}.
  \item Essential theory for understanding the parser generator \textsc{Ply} is then presented.
  \item Lastly, we discuss the limitations of context-free languages.
  \end{enumerate}

\item The final part of this lecture covers interpreters and compilers.
  \begin{enumerate}[(a)]
  \item We implement an interpreter for a toy language.
  \item Then we discuss how to write a compiler that translates another toy language into \blue{Java byte code}.
  \end{enumerate}
\end{enumerate}

\section{Literature}
Besides these lecture notes, there are three books I highly recommend:
\begin{enumerate}[(a)]
\item \emph{Introduction to Automata Theory, Languages, and Computation} \cite{hopcroft:06}
      --- Often considered   the definitive text on formal languages, this book encompasses all the theoretical
      concepts discussed in this lecture, although we will only touch on a subset of its content. 
\item \emph{Introduction to the Theory of Computation} \cite{sipser:2012}
      --- This book provides another accessible introduction to formal languages and extends to the theory of
      computability, which is beyond the scope of this lecture. 
\item \emph{Compilers --- Principles, Techniques and Tools} \cite{aho:2006}
      --- A standard reference in compiler theory, this book also covers a substantial portion of formal languages.
\item The tool \href{https://openai.com/blog/chatgpt-plus}{\emph{ChatGPT Plus}} has reached a quality level
      that allows it to serve as a tutor for many concepts discussed in this course.
\end{enumerate}

\section{Check your Understanding}
\begin{enumerate}[(a)]
\item Define what is meant by an \blue{alphabet}.
\item Based on a given alphabet, define the concept of a \blue{string}.
\item Elaborate on the notion of a \blue{formal language}.
\end{enumerate}


%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "formal-languages.tex"
%%% End: 

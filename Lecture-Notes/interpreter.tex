\chapter{Interpreter \label{chapter:interpreter}}


\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  firstnumber   = 1,
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.8cm,
                  xrightmargin  = 0.8cm,
                ]
    grammar Pure;
    
    program  : statement+
             ;  
    statement: VAR ':=' expr ';'
             | VAR ':=' 'read' '(' ')' ';'
             | 'print' '(' expr ')' ';'
             | 'if'    '(' boolExpr ')' '{' statement* '}'
             | 'while' '(' boolExpr ')' '{' statement* '}'
             ;
    boolExpr : expr '==' expr
             | expr '<'  expr
             ;
    expr     : expr '+' product
             | expr '-' product
             | product
             ;
    product  : product '*' factor
             | product '/' factor
             | factor
             ;
    factor   : '(' expr ')'
             | VAR
             | NUMBER
             ;
    VAR      : [a-zA-Z][a-zA-Z_0-9]*;
    NUMBER   : '0'|[1-9][0-9]*;
    MULTI_COMMENT : '/*' .*? '*/' -> skip;
    LINE_COMMENT  : '//' ~('\n')* -> skip;
    WS            : [ \t\n\r]     -> skip; 
\end{Verbatim}
\vspace*{-0.3cm}
\caption{\textsc{Antlr}-Grammatik f\"ur eine einfache Programmier-Sprache.}
\label{fig:Pure.g4}
\end{figure}

In diesem Kapitels erstellen wir mit Hilfe des Parser-Generators \textsc{Antlr} einen
Interpreter für eine einfache Programmiersprache.  Erfreulicherweise akzeptiert
\textsc{Antlr} seit der Version \texttt{4.0} auch Grammatiken, die einfache Links-Rekursion
enthalten.  Auch eine Links-Faktorisierung der Grammatik ist nicht mehr notwendig.
Abbildung \ref{fig:Pure.g4} zeigt die \textsc{Antlr}-Grammatik der Programmier-Sprache, für die wir
in diesem Abschnitt einen Interpreter entwickeln.  Die Befehle dieser Sprache sind Zuweisungen, Print-Befehle,
\texttt{if}-Abfragen, sowie \texttt{while}-Schleifen.  Abbildung \ref{fig:sum.sl} zeigt
ein Beispiel-Programm, das dieser Grammatik entspricht.  Dieses Programm liest zunächst eine Zahl
ein, die in der Variablen \texttt{n} gespeichert wird.  Anschlie{\ss}end wird die Summe
\\[0.2cm]
\hspace*{1.3cm}
$\ds\sum\limits_{\mbox{$\normalsize i=1$}}^{\mbox{$\normalsize n^2$}} \mbox{\Large $i$}$
\\[0.2cm]
in der Variablen \texttt{s} akkumuliert und am Ende des Programms ausgegeben.


\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.8cm,
                  xrightmargin  = 0.8cm,
                ]
    n := read();
    s := 0;
    i := 0;
    while (i < n * n) {
        i := i + 1;
        s := s + i;
    }
    print(s);
\end{Verbatim}
\vspace*{-0.3cm}
\caption{Ein Programm zur Berechnung der Summe $\sum\limits_{i=0}^{n^2} i$.}
\label{fig:sum.sl}
\end{figure}


Ähnlich wie bei unserem Programm zum symbolischen Differenzieren werden wir die einzelnen Befehle als
geschachtelte Listen darstellen.

\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.0cm,
                  xrightmargin  = 0.0cm,
                ]
    grammar Simple;
    
    program returns [stmnt_list]
        @init {SL = []}    
        : (s = statement {SL.append($s.stmnt)})+ {$stmnt_list = SL}
        ;
    
    statement returns [stmnt]
        @init {SL = []}
        : v = VAR ':=' e = expr ';'       {$stmnt = (':=', $v.text, $e.result)}
        | v = VAR ':=' 'read' '(' ')' ';' {$stmnt = ('read', $v.text)}
        | 'print' '(' r = expr ')' ';'    {$stmnt = ('print', $r.result)}
        | 'if' '(' b = boolExpr ')' '{' (l = statement {SL.append($l.stmnt) })* '}' 
          {$stmnt = ('if', $b.result, SL)}
        | 'while' '(' b = boolExpr ')' '{' (l = statement {SL.append($l.stmnt) })* '}' 
          {$stmnt = ('while', $b.result, SL)}
        ;
    
    boolExpr returns [result]
        : l = expr '==' r = expr {$result = ('==', $l.result, $r.result)} 
        | l = expr '<'  r = expr {$result = ('<',  $l.result, $r.result)}
        ;
    
    expr returns [result]
        : e = expr '+' p = product {$result = ('+', $e.result, $p.result)}
        | e = expr '-' p = product {$result = ('-', $e.result, $p.result)}
        | p = product              {$result = $p.result}
        ;
    
    product returns [result]
        : p = product '*' f = factor {$result = ('*', $p.result, $f.result)}
        | p = product '/' f = factor {$result = ('/', $p.result, $f.result)}
        | f = factor                 {$result = $f.result}
        ;
    
    factor returns [result]
        : '(' expr ')' {$result = $expr.result}
        | v = VAR      {$result = $v.text}
        | n = NUMBER   {$result = int($n.text)}
        ;
\end{Verbatim}
\vspace*{-0.3cm} %\$
\caption{\textsc{Antlr}-Spezifikation der Grammatik.}
\label{fig:Simple.g}
\end{figure}

\noindent
Abbildung \ref{fig:Simple.g} zeigt die Implementierung des Parsers mit dem
Werkzeug \textsc{Antlr}.  
\begin{enumerate}
\item Das Start-Symbol der Grammatik ist die Variable \texttt{program}.
      Beim Parsen dieser Variable gibt der Parser eine Liste von Befehlen in der Variable
      \texttt{stmnt\_list} zurück.
      Dazu initialisieren wir mit Hilfe des Schlüsselwortes ``\texttt{\symbol{64}init}'' die Variable \texttt{SL}
      als leere Liste.  Anschließend wird jeder Befehl, der erkannt wird, an diese Liste angehängt.
      Schließlich wird diese Liste in der Attribut-Variable \texttt{stmnt\_list} gespeichert.
\item Die syntaktische Variable \texttt{statement} beschreibt die verschiedenen Befehle, die 
      in unserer einfachen Sprache unterstützt werden.
      \begin{enumerate}[(a)]
      \item Die einfachsten Befehle sind die Zuweisungen.  Diese haben die Form:
            \\[0.2cm]
            \hspace*{1.3cm}
            $v \;\texttt{:=}\; e \texttt{;}$
            \\[0.2cm]
            Hierbei ist $v$ eine Variable und $e$ ist ein arithmetischer Ausdruck.
            Eine solche Zuweisung wird durch das geschachtelte Tupel
            \\[0.2cm]
            \hspace*{1.3cm}
            $(\texttt{':='}, v, e)$
            \\[0.2cm]
            dargestellt.
      \item Der Befehl zum Einlesen einer Zahl hat die Form:
            \\[0.2cm]
            \hspace*{1.3cm}
            $v \;\texttt{:=}\; \texttt{read()} \texttt{;}$
            \\[0.2cm]
            Die Aufgabe dieses Befehl ist es, den vom Benutzer eingegebenen Text in eine Zahl umzuwandeln, die
            dann in der Variablen $v$ abgespeichert wird.  Der Befehl wird durch das geschachtelte Tupel
            \\[0.2cm]
            \hspace*{1.3cm}
            $(\texttt{'read'}, v)$
            \\[0.2cm]
            dargestellt.
      \item Der Befehl zur Ausgabe eines Wertes hat die Form:
            \\[0.2cm]
            \hspace*{1.3cm}
            $\texttt{print(} e \texttt{);}$
            \\[0.2cm]
            Die Aufgabe dieses Befehl ist es, den Wert des Ausdrucks $e$ zu berechnen und auszugeben.
            Dieser Befehl wird durch das geschachtelte Tupel
            \\[0.2cm]
            \hspace*{1.3cm}
            $(\texttt{'print'}, v)$
            \\[0.2cm]
            dargestellt.
      \item Ein Test hat die Syntax:
            \\[0.2cm]
            \hspace*{1.3cm}
            $\texttt{if}\; \texttt{(}\; b\; \texttt{)}\; \texttt{\{}\; \textsl{statements}\; \texttt{\}}$
            \\[0.2cm]
            Hierbei ist $b$ ein Ausdruck, dessen Auswertung \texttt{True} oder \texttt{False} ergibt
            und \texttt{statements} ist eine Liste von Befehlen, die ausgeführt werden, falls
            $b$ den Wert \texttt{True} hat.
            Dieser Befehl wird durch das geschachtelte Tupel
            \\[0.2cm]
            \hspace*{1.3cm}
            $(\texttt{'if'}, b, \textsl{statements})$
            \\[0.2cm]
            dargestellt.
      \item Eine Schleife hat die Syntax:
            \\[0.2cm]
            \hspace*{1.3cm}
            $\texttt{while}\; \texttt{(}\; b\; \texttt{)}\; \texttt{\{}\; \textsl{statements}\; \texttt{\}}$
            \\[0.2cm]
            Hierbei ist $b$ ein Ausdruck, dessen Auswertung \texttt{True} oder \texttt{False} ergibt
            und \texttt{statements} ist eine Liste von Befehlen, die ausgeführt werden, solange
            $b$ den Wert \texttt{True} hat.
            Dieser Befehl wird durch das geschachtelte Tupel
            \\[0.2cm]
            \hspace*{1.3cm}
            $(\texttt{'while'}, b, \textsl{statements})$
            \\[0.2cm]
            dargestellt.
      \end{enumerate}
\item Die syntaktische Variable \texttt{boolExpr} beschreibt einen Ausdruck, der einen Boole'schen Wert
      annimmt.  Es gibt zwei Möglichkeiten einen solchen Wert zu erzeugen.
      \begin{enumerate}
      \item Ein Ausdruck der Form
            \\[0.2cm]
            \hspace*{1.3cm}
            $l \;\texttt{==}\; r $
            \\[0.2cm]
            testet, ob die Auswertungen von $l$ und $r$ die selben Werte ergeben.
            Dieser Befehl Ausdruck wird durch das geschachtelte Tupel
            \\[0.2cm]
            \hspace*{1.3cm}
            $(\texttt{'=='}, l, r)$
            \\[0.2cm]
            dargestellt.
      \item Ein Ausdruck der Form
            \\[0.2cm]
            \hspace*{1.3cm}
            $l \;\texttt{<}\; r $
            \\[0.2cm]
            testet, ob die Auswertung von $l$ einen Wert ergibt, der kleiner ist als der Wert, der sich bei der
            Auswertung von $r$ ergibt.
            Dieser Befehl Ausdruck wird durch das geschachtelte Tupel
            \\[0.2cm]
            \hspace*{1.3cm}
            $(\texttt{'<'}, l, r)$
            \\[0.2cm]
            dargestellt.
      \end{enumerate}
\item In analoger Weise beschreiben die Variablen \texttt{expr}, \texttt{product} und \texttt{factor}
      arithmetische Ausdrücke. 
      Da wir dies bereits hinlänglich früher diskutiert haben, gehen wir an dieser Stelle nicht weiter auf
      die Grammatik-Regeln ein, durch die diese Variablen definiert werden. 
\end{enumerate}

\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  firstnumber   = last,
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.0cm,
                  xrightmargin  = 0.0cm,
                ]
    
    VAR    : [a-zA-Z][a-zA-Z_0-9]*;
    NUMBER : '0'|[1-9][0-9]*;
    
    MULTI_COMMENT : '/*' .*? '*/' -> skip;
    LINE_COMMENT  : '//' ~('\n')* -> skip;
    WS            : [ \t\n\r]     -> skip;
\end{Verbatim}
\vspace*{-0.3cm}
\caption{\textsc{Antlr}-Spezifikation der verschiedenen Token.}
\label{fig:Simple-2.g}
\end{figure}
Die Spezifikation der Token ist in Abbildung \ref{fig:Simple-2.g}
gezeigt.  Der Scanner unterscheidet im Wesentlichen zwischen Variablen und Zahlen.
Variablen beginnen mit einem großen oder kleinen Buchstaben, auf den dann zusätzlich Ziffern und der
Unterstrich folgen können.  Folgen von Ziffern werden als Zahlen interpretiert.  Enthält eine solche
Folge mehr als ein Zeichen, so darf die erste Ziffer nicht 0 sein.  Darüber hinaus entfernt der
Scanner Whitespace und Kommentare.   Außerdem haben wir bei der
Spezifikation von mehrzeiligen Kommentaren die sogenannte \emph{non-greedy}-Version des Operators
``\texttt{*}'' benutzt.  Die non-greedy-Version des Operators ``\texttt{*}'' wird als
``\texttt{*?}'' geschrieben und matched sowenig wie möglich.  Daher steht der reguläre Ausdruck
\\[0.2cm]
\hspace*{1.3cm}
\texttt{'/*' .*? '*/'}
\\[0.2cm]
für einen String, der mit der Zeichenkette ``\texttt{/*}'', mit der Zeichenkette ``\texttt{*/}''
endet und außerdem so kurz wie möglich ist.  Dadurch werden in einer Zeile der Form
\\[0.2cm]
\hspace*{1.3cm}
\texttt{/* Hugo */ i := i + 1; /* Anton */}
\\[0.2cm] 
zwei getrennte Kommentare erkannt.


\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  firstnumber   = 1,
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.0cm,
                  xrightmargin  = 0.0cm,
                ]
    def main(file):
        with open(file, 'r') as handle:
            program_text = handle.read()
        input_stream  = antlr4.InputStream(program_text)
        lexer         = SimpleLexer(input_stream)
        token_stream  = antlr4.CommonTokenStream(lexer)
        parser        = SimpleParser(token_stream)
        result        = parser.program()
        execute_list(result.stmnt_list)
\end{Verbatim}
\vspace*{-0.3cm}
\caption{Die Funktion \texttt{InputReader}.}
\label{fig:Interpreter.ipynb:main}
\end{figure}



\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  firstnumber   = 1,
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.0cm,
                  xrightmargin  = 0.0cm,
                ]
    def execute_list(Statement_List, Values={}):
        for stmnt in Statement_List:
            execute(stmnt, Values)
    
    def execute(stmnt, Values):
        op = stmnt[0]
        if op == ':=':
            _, var, value = stmnt
            Values[var] = evaluate(value, Values)
        elif op == 'read':
            _, var = stmnt
            Values[var] = int(input())
        elif op == 'print':
            _, expr = stmnt
            print(evaluate(expr, Values))
        elif op == 'if':
            _, test, SL = stmnt
            if evaluate(test, Values):
                execute_list(SL, Values)
        elif op == 'while':
            _, test, SL = stmnt
            while evaluate(test, Values):
                execute_list(SL, Values)
        else:
            assert False, f'{stmnt} unexpected'
\end{Verbatim}
\vspace*{-0.3cm}
\caption{Die Funktion \texttt{execute}.}
\label{fig:Interpreter.ipynb:execute}
\end{figure}

\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  firstnumber   = 1,
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.0cm,
                  xrightmargin  = 0.0cm,
                ]
    def evaluate(expr, Values):
        if isinstance(expr, int):
            return expr
        if isinstance(expr, str):
            return Values[expr] 
        op = expr[0]
        if op == '==':
            _, lhs, rhs = expr
            return evaluate(lhs, Values) == evaluate(rhs, Values)
        if op == '<':
            _, lhs, rhs = expr
            return evaluate(lhs, Values) < evaluate(rhs, Values)
        if op == '+':
            _, lhs, rhs = expr
            return evaluate(lhs, Values) + evaluate(rhs, Values)
        if op == '-':
            _, lhs, rhs = expr
            return evaluate(lhs, Values) - evaluate(rhs, Values)
        if op == '*':
            _, lhs, rhs = expr
            return evaluate(lhs, Values) * evaluate(rhs, Values)
        if op == '/':
            _, lhs, rhs = expr
            return evaluate(lhs, Values) / evaluate(rhs, Values)
        assert False, f'{stmnt} unexpected'
\end{Verbatim}
\vspace*{-0.3cm}
\caption{Die Funktion \texttt{evaluate}.}
\label{fig:Interpreter.ipynb:evaluate}
\end{figure}





\exercise
\begin{enumerate}
\renewcommand{\labelenumi}{(\alph{enumi})}
\item Erweitern Sie den Interpreter so, dass auch der Operator ``\texttt{<=}'' unterstützt wird.
\item Erweitern Sie den Interpreter um \texttt{for}-Schleifen.
\item Erweitern Sie den Interpreter um die logischen Operatoren
      ``\texttt{\&\&}'' für das logische \emph{Und}, ``\texttt{||}'' für das logische \emph{Oder}
      und ``\texttt{!}'' für die Negation an.  Dabei soll der Operator ``\texttt{!}'' am
      stärksten und der Operator ``\texttt{||}'' am schwächsten binden.
\item Erweitern Sie die Syntax der arithmetischen Ausdrücke so, dass auch vordefinierte 
      mathematische Funktionen wie $\texttt{exp}()$ oder $\texttt{ln}()$ benutzt werden
      können.

      \textbf{Hinweis}:  Wenn Sie das Paket \texttt{java.lang.reflect} benutzen,
      kommen Sie mit einer zusätzlichen Klasse aus und können damit alle in
      \texttt{java.lang.Math} definierten Methoden implementieren.
\item Erweitern Sie den Interpreter so, dass auch benutzerdefinierte Funktionen möglich
      werden. 
      
      \textbf{Hinweis}: Jetzt müssen Sie zwischen lokalen und globalen Variablen
      unterscheiden.
      Daher reicht es nicht mehr, die Belegungen der Variablen in einer
      global definierten Hashtabelle zu verwalten. \eox
\item Erweitern Sie den Interpreter so, dass die Verwendung rationaler Zahlen unterstützt wird.
      Das Ziel dieser Erweiterung ist eine Sprache, mit der Sie Rechnungen ohne Rundungsfehler durchführen können.
\end{enumerate}
\renewcommand{\labelenumii}{\arabic{enumii}.}


%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "formal-languages"
%%% End: 

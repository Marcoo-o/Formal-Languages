\chapter{Building Scanners with \textsl{Ply}}
After having defined regular expressions we will now get a taste of their power in practise.
To this end we discuss the tool \textsc{Ply} \index{$\textsc{Ply}$}, which can generate both 
\emph{scanners} and \emph{parsers}.
A  \blue{scanner} \index{scanner} is a program that splits a given string into a list of \emph{tokens}, 
where a \blue{token} \index{token} is a group of consecutive characters that belong together logically.  An example
will clarify this.   
The input for a \texttt{C}-compiler is an \textsc{Ascii}-string that can be interpreted as a
valid \texttt{C} program.  In order to translate this string into machine language, the
\texttt{C}-compiler first groups the different characters into tokens.  In the case of a \texttt{C}
program, the compiler generates the following tokens:
\begin{enumerate}
\item \blue{Keywords}, a.k.a.~reserved words like ``\texttt{if}'', ``\texttt{while}'', or ``\texttt{case}''.
\item \blue{Operator symbols} like ``\texttt{+}'', ``\texttt{+=}'', ``\texttt{<}'', or
      ``\texttt{<=}''. 
\item \blue{Parentheses} like ``\texttt{(}'', ``\texttt{[}'', and ``\texttt{\{}'' and the
      corresponding closing symbols.
\item \blue{Constants}.  The language \texttt{C} distinguishes between three different kinds of constants:
      \begin{enumerate}
      \item Numbers, for example the integer ``\texttt{123}'' or the floating point number ``\texttt{1.23e2}''.
      \item Strings, which are enclosed in double.  For example,
            ``\texttt{\symbol{34}hallo\symbol{34}}'' is a string constant.  Note that the character
            ``\texttt{\symbol{34}}'' is part of the string constant, while the opening and closing
            quotes surrounding the string constant have been used to separate the string constant
            from the surrounding text. 
      \item Single letters that are enclosed in single quotes as in
            ``\texttt{\symbol{39}a\symbol{39}}''.
      \end{enumerate}
\item \blue{Identifiers} that can act as variable names, function names, or type names.
\item \blue{Comments}, which come in two flavors:  \blue{Single line comments} start with the string
      ``\texttt{//}'' and extend to the end of the line, while \blue{multi line comments} start with
      the string ``\texttt{/*}'' and are ended by ``\texttt{*/}''.
\item So called \blue{white space characters}.  For example the blank, tabulators, line breaks, and
      carriage returns are white space symbols.
\end{enumerate}

\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  firstnumber   = 1,
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.8cm,
                  xrightmargin  = 0.8cm,
                ]
    /* Hello World program */
    #include<stdio.h>
    
    int main() {
        printf("Hello World!\n");
        return 1;
    }
\end{Verbatim}
\vspace*{-0.3cm}
\caption{A simple \texttt{C} program.}
\label{fig:hello-world.c}
\end{figure}

To make things more precise, Figure \ref{fig:hello-world.c} contains a \texttt{C} program that
prints the string ``\texttt{Hello World!}'' followed by a newline character.  The scanner would
transform this program into the following list of tokens:
\begin{verbatim}
   [ "/* Hello World program */", "#", "include", "<", "stdio.h", ">",
     "int", "main", "(", ")", "{", "printf", "(", "Hello World!\n", ")", ";"
     "return", "1", ";", "}"
   ]
\end{verbatim}
Note that the scanner discards the white space characters.  They only serve to separate tokens.


\section{The Structure of a \textsc{Ply} Scanner Specification}
In this section we introduce \href{https://www.dabeaz.com/ply/}{Python Lex-Yacc} also known as \textsc{Ply}.
As the home page of \textsc{Ply} states, ``\textsc{Ply} is an implementation of the lex and yacc parsing tools
for \textsl{Python}''.  The tool has been developed by \href{https://www.dabeaz.com/}{David Beazley}.  In this
section, we only discuss \textsc{Ply} as a scanner generator.  In Chapter \ref{chapter:ply} we will discuss how
\textsc{Ply}  can be used to generate a parser.

We begin with a simple example.  In general, a \textsc{Ply} scanner specification is made up of three parts.
Figure \ref{fig:Ply-Example.ipynb} shows how a scanner is specified that can tokenize arithmetical expressions.
This example has been taken from the official \textsc{ply}
\href{https://ply.readthedocs.io/en/latest/ply.html#specification-of-tokens}{documentation}. 
\begin{enumerate}
\item The module \texttt{ply.lex} contains the definition of the function \texttt{ply.lex.lex()}
      that is able to generate a scanner.
      Therefore, this module is imported in line 1.
\item The first part of a scanner specification is the \blue{token declaration section}.
      Syntactically, this is just a list containing the names of all tokens.  Note that all token names have to
      start with a capital 
      letter.

      In Figure \ref{fig:Ply-Example.ipynb} the token declaration section extends from line 3 to line 11.
\item The second part contains the \blue{token definitions}.  There are two kinds of token definitions:
      \begin{enumerate}
      \item \blue{Immediate token definitions} \index{immediate token definition} have the following form:
            \\[0.2cm]
            \hspace*{1.3cm}
            \texttt{t\_\textsl{name} = r'\textsl{regexp}'}
            \\[0.2cm]
            Here \textsl{name} has to be one of the names declared in the declaration section and
            \textsl{regexp} is a regular expression using the syntax that is specified in the 
            \textsl{Python} \href{https://docs.python.org/3/library/re.html}{\texttt{re}} module.
      \item \blue{Functional token definitions} \index{functional token definitions} are syntactically
            \textsl{Python function definitions} and have the following form:
            \\[0.2cm]
            \hspace*{1.3cm}
            \texttt{def t\_\textsl{name}(t):} \\
            \hspace*{2.05cm}
            \texttt{r'\textsl{regexp}'} \\
            \hspace*{2.8cm} $\vdots$ \\[0.2cm]
            Here, the vertical dots $\vdots$ denote any \textsl{Python} code, while
            \textsl{name} has to be one of the token names declared in the declaration section and
            \textsl{regexp} is a regular expression.
            
            The functional token definition shown in line 20--23 takes a token \texttt{t} as its
            argument.  This token has the attribute \texttt{t.value}, which refers to the string that has been
            recognized as this token.  In this case, this string is a sequence of digits that can be
            interpreted as a number.  In line 22 the function  \texttt{t\_NUMBER} converts this string into a
            number and stores this number as the attribute \texttt{t.value}.  Finally, the token \texttt{t}
            itself is returned.  This is a typical case where we need a functional token definition since we 
            want to modify the token that is returned.
      \end{enumerate}
      In Figure \ref{fig:Ply-Example.ipynb} the token definitions start in line 13 and end in line 23.
\item The third part deals with the handling of newlines, ignored characters, and scanner errors.
  \begin{enumerate}
  \item A \textsc{Ply} input file may contain the definition of the function \texttt{t\_newline}.
        This function is supposed to deal with newlines contained in the input.  Its main purpose is to set the 
        counter \texttt{t.lexer.lineno}.  Every token \texttt{t} has the attribute \texttt{t.lexer}, which is a
        reference to the scanner object.  In turn, the scanner object has the attribute \texttt{lineno}, which
        is supposed to be an integer containing the number of the line currently scanned.  This integer starts
        at the value $1$.  Every time a newline is read it should be incremented.

        In line 26 the regular expression \texttt{r'\symbol{92}+'} matches any positive number of newlines.
        Hence the counter \texttt{lineno} has to be incremented by the length of the string \texttt{t.value.}

        Note that the function \texttt{t\_newline} does \underline{not} return a token.
  \item Line 29 specifies that both blanks and tabs should be ignored by the scanner.
        Note that the string 
        \\[0.2cm]
        \hspace*{1.3cm}
        ``\texttt{' \symbol{92}t'}'' 
        \\[0.2cm]
        is \underline{not} interpreted as a regular expression
        but rather as a list of its characters.  Furthermore, this is not a raw string and must not be prefixed
        with the character ``\texttt{r}'', for otherwise the character sequence ``\texttt{\symbol{92}t}'' would not be
        interpreted as a tab symbol.
  \item The function \texttt{t\_error} deals with characters that can not be recognized.
        An error message is printed and the call \texttt{t.lexer.skip(1)} discards the character that could not be
        matched. 
  \end{enumerate}
\item In line 35 the function \texttt{lex.lex} creates the scanner that has been specified.
\item Line 38 shows how data can be fed into this scanner.
\item In order to use this scanner we can just iterate over it as shown in line 40.  This iteration scans the
      input string using the generated scanner and produces the tokens that are recognized by the scanner one
      by one.
\end{enumerate}

\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.8cm,
                  xrightmargin  = 0.8cm,
                ]
    import ply.lex as lex
    
    tokens = [
       'NUMBER',
       'PLUS',
       'MINUS',
       'TIMES',
       'DIVIDE',
       'LPAREN',
       'RPAREN'
    ]
    
    t_PLUS    = r'\+'
    t_MINUS   = r'-'
    t_TIMES   = r'\*'
    t_DIVIDE  = r'/'
    t_LPAREN  = r'\('
    t_RPAREN  = r'\)'
    
    def t_NUMBER(t):
        r'0|[1-9][0-9]*'
        t.value = int(t.value)
        return t
    
    def t_newline(t):
        r'\n+'
        t.lexer.lineno += len(t.value)
    
    t_ignore  = ' \t'
    
    def t_error(t):
        print("Illegal character '%s'" % t.value[0])
        t.lexer.skip(1)
    
    lexer = lex.lex()
    
    data = '3 + 4 * 10 + 007 + (-20) * 2'
    lexer.input(data)
    
    for tok in lexer:
        print(tok)
\end{Verbatim}
\vspace*{-0.3cm}
\caption{A simple scanner Specification for \textsc{Ply}.}
\label{fig:Ply-Example.ipynb}
\end{figure}

\noindent
If we run the program shown in Figure \ref{fig:Ply-Example.ipynb} we get the following output:
\begin{verbatim}
    LexToken(NUMBER,3,1,0)
    LexToken(PLUS,'+',1,2)
    LexToken(NUMBER,4,1,4)
    LexToken(TIMES,'*',1,6)
    LexToken(NUMBER,10,1,8)
    LexToken(PLUS,'+',1,11)
    LexToken(NUMBER,0,1,13)
    LexToken(NUMBER,0,1,14)
    LexToken(NUMBER,7,1,15)
    LexToken(PLUS,'+',1,17)
    LexToken(LPAREN,'(',1,19)
    LexToken(MINUS,'-',1,20)
    LexToken(NUMBER,20,1,21)
    LexToken(RPAREN,')',1,23)
    LexToken(TIMES,'*',1,25)
    LexToken(NUMBER,2,1,27)
\end{verbatim}
As we can see the tokens returned by our scanner are objects of class \texttt{LexToken}.  These objects have
four attributes:
\begin{enumerate}
\item The first attribute is called \texttt{type}.  Its value is a string that is the name of
      one of the declared tokens.
\item The second attribute is called \texttt{value}.  Normally, this is the string that has been 
      recognized but we are allowed to change this attribute.  For example, the function \texttt{t\_NUMBER}
      converts the recognized string into an integer value.
\item The third attribute is called \texttt{lineno}.  This specifies the line number where the token has been found.
\item The last attribute is called \texttt{lexpos}.  This is a counter that is incremented with every
      character that is read.
\end{enumerate}

\homeworkEng
Install \textsc{PLy} and make sure that the example presented previously works.  

\section{The Syntax of Regular Expressions in \textsl{Python}}
In the previous chapter we have defined regular expressions using only a minimal amount of syntax. 
Using as little syntax as possible is beneficial for our upcoming theoretical investigations of
regular expression in the next chapter where we show that regular expressions can be implemented
using finite state machines.  However, for practical applications it is useful to considerably
enrich the syntax of regular expressions that we have seen so far.
For this reason, the \textsl{Python} module \textsl{re} provides a number of abbreviations that enable us to denote
complex regular expressions in a more compact form.  I have written a short 
\href{https://github.com/karlstroetmann/Formal-Languages/blob/master/Python/Regexp-Tutorial.ipynb}{tutorial}
that introduces the most important features of the regular expressions defined in the module \texttt{re}.
As it is best to read this tutorial interactively, this section only contains the reference
\\[0.2cm]
\hspace*{1.3cm}
\href{https://github.com/karlstroetmann/Formal-Languages/blob/master/Python/Regexp-Tutorial.ipynb}{https://github.com/karlstroetmann/Formal-Languages/blob/master/Python/Regexp-Tutorial.ipynb}
\\[0.2cm]
that points to this tutorial.

\section{A Complex Example: Evaluating an Exam}
This sections presents a more complex example that shows some of the power of \textsl{JFlex}.  The
task at hand is the evaluation of an exam.  When I mark an exam I create a file that has a format
similar to the example shown in Figure \ref{fig:result.txt}. 

\begin{figure}[!h]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.8cm,
                  xrightmargin  = 0.8cm,
                  commandchars  = \\\{\}
                ]
    Class: Algorithms and Complexity
    Group: TIT09AID
    MaxPoints = 60
   
    Exercise:      1. 2. 3. 4. 5. 6.
    Jim Smith:     9 12 10  6  6  0
    John Slow\footnote{}:\,    4  4  2  0  -  -
    Susi Sorglos:  9 12 12  9  9  6
\end{Verbatim}
\vspace*{-0.3cm}
\caption{Results of an Exam}
\label{fig:result.txt}
\end{figure}

\footnotetext[1]{You know nothing, John Slow.}

\begin{enumerate}
\item The first line contains the keyword ``\texttt{Class}'', a colon ``\texttt{:}'', and then the
      name of the lecture. 
\item The second line specifies the group that has taken the exam.
\item The third line specifies the number of points that are necessary to obtain the best mark.
\item The fourth line is empty.
\item The fifth line numbers the exercises.
\item After that, there is a table.  Every row in this table lists the scores achieved by a student
      for each of the exercises.  The name of each student is at the beginning of each row.  The
      name is followed by a colon and after that there is a list of the scores achieved for each
      exercise.  If an exercise has not been attempted at all, the corresponding column contains a hyphen
      ``\texttt{-}''.
\end{enumerate}
I have written a \textsl{Jupyter notebook} that is able to evaluate data of this kind.
You can find the notebook here:
\\[0.2cm]
\hspace*{1.3cm}
\href{https://github.com/karlstroetmann/Formal-Languages/blob/master/Ply/Exam-Evaluation.ipynb}{https://github.com/karlstroetmann/Formal-Languages/blob/master/Ply/Exam-Evaluation.ipynb}

\section{Scanner States}
In this section we will develop a program that is able to convert an 
\textsc{Html} file into a pure text file.  This program is actually quite useful: Some years ago I
had a student that was blind.  If he read a web page, he would use his Braille display.  For him,
the \textsc{Html} markup was of no use so if the markup was removed, he could read web pages faster.

The \textsl{JFlex} program shown in Figure \ref{fig:html2txt.jflex} works as follows:
\begin{enumerate}
\item First, the head of an  \textsc{Html} file is removed.  The head of an \textsc{Html} file is
      enclosed in the  tags ``\texttt{<head>}'' and ``\texttt{</head>}''.
\item Furthermore, the \textsl{JavaScript} that is part of the \textsc{Html} file is also removed.
\item Finally, all  \textsc{Html} tags are removed.
\end{enumerate}
All this is done via the use of so called \blue{scanner states}.  In the example, there are two
scanner states.  They are declared via the keyword
``\texttt{\symbol{37}xstate}''. 

\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.8cm,
                  xrightmargin  = 0.8cm,
                ]
    package Converter;
    
    %% 
    
    %class Html2Txt
    %standalone
    %line
    %unicode
    
    %xstate header script
    %%
    
    "<head>"            { yybegin(header);         }
    "<script"[^>]+">"   { yybegin(script);         }
    "<"[^>]+">"         { /* skip html tags */     }
    \R+                 { System.out.print("\n");  }
    &nbsp;              { System.out.print(" ");   }
    &auml;              { System.out.print("\"a");   }
    &ouml;              { System.out.print("\"o");   }
    &uuml;              { System.out.print("\"u");   }
    &Auml;              { System.out.print("\"A");   }
    &Ouml;              { System.out.print("\"O");   }
    &Uuml;              { System.out.print("\"U");   }
    &szlig;             { System.out.print("{\ss}");   }
    
    <header>"</head>"   { yybegin(YYINITIAL);      }
    <header>.|\R        { /* skip anything else */ }
    
    <script>"</script>" { yybegin(YYINITIAL);      }
    <script>.|\R        { /* skip anything else */ }
\end{Verbatim}
\vspace*{-0.3cm}
\caption{Transformation einer \textsc{Html}-Datei in eine reine Text-Datei}
\label{fig:html2txt.jflex}
\end{figure}

We proceed to discuss the details of the \textsl{JFlex} program shown in Figure \ref{fig:html2txt.jflex}.
\begin{enumerate}
\item Line  10 declares the scanner states \texttt{header} and \texttt{script}.  The keyword ``\texttt{\%xstate}''
      tells us that these states are  \blue{exclusive} scanner states.  We will discuss the difference
      between exclusive and inclusive states later.
      The general syntax of state declaration is as follows:
      \begin{enumerate}
      \item A state declaration is either started with the keyword ``\texttt{\symbol{37}xstate}''
            or the keyword ``\texttt{\symbol{37}state}''.  The keyword
            ``\texttt{\symbol{37}xstate}'' declares \blue{exclusive} states, while
            ``\texttt{\symbol{37}state}'' declares  \blue{inclusive} states.  The 
            difference between these two kinds of states is discussed later.
      \item After the keyword specifying the states as either inclusive or exclusive we have a list
            of the names of the states.  These names are separated by blanks.
      \end{enumerate}
\item In line 13 we recognize the string  ``\texttt{<head>}''.  In this case, we execute the action 
      ``\texttt{yybegin(header)}''.  This action switches the state of the scanner from the default
      state ``\texttt{YYINITIAL}'' to  the state ``\texttt{header}''.   
      As we had declared the state \texttt{header} to be an  exclusive state, the scanner is only
      able to execute those rules that are marked with the prefix ``\texttt{<header>}''.
      If the state had been declared as an inclusive state, then all rules that are not prefixed
      with a state would also be applicable.  
      
      We find rules for the state ``\texttt{header}'' in the lines  26 and 27.
\item Line 14 switches to the state ``\texttt{script}'' if the scanner encounters an opening
      \texttt{script} tag.
\item Line  15 reads all remaining tags.  Since the action is empty, these tags are removed.
\item Line 16 replaces the string  ``\texttt{\&nbsp;}'' by a blank.
\item The following lines replaces the  \textsc{Html} representation of strange German characters with
      the corresponding characters.
\item Line 26 is declared to be a rule for the state ``\texttt{header}''.  Hence, this rule is only
      active if the scanner is in the state ``\texttt{header}''.  This rule searches for the closing tag
      ``\texttt{</head>}''.  If this tag is found, the scanner changes back into the default state
      \texttt{YYINITIAL}.  In the default state, the scanner uses only those rules that are not
      prefixed with a state. 
\item Line 27 contains another rule that is only used in the state  ``\texttt{header}''.
      This rule reads an arbitrary character, which is not processed further and hence is simply
      discarded. 
\item The lines  29 and 30 contain similar rules that are used in the state
      ``\texttt{script}''.
\end{enumerate}
\pagebreak

\exerciseEng
Some programming languages allow nested comments.  Create a \textsl{JFlex} program that is able to
remove nested comments of the form
\\[0.2cm]
\hspace*{1.3cm}
\texttt{/*} $\cdots$ \texttt{*/}
\\[0.2cm]
from a given program.  Furthermore, assume that the program might contains strings that are
contained in double quotes.  Now if either the character sequence ``\texttt{/*}'' or the character
sequence ``\texttt{*/}'' occurs inside a string, then these character sequences should not be
interpreted as comment delimiters. 
\eox
\vspace*{0.3cm}

The next exercise is meant to improve the fun factor of my lecture.

\exerciseEng
The purpose of this exercise is to transform \href{http://www.latex-project.org}{\LaTeX} into 
\href{https://www.tutorialspoint.com/mathml/index.htm}{\textsc{MathML}}.  \LaTeX\ is a document markup language
that is especially well suited to present text that contains mathematical formul\ae.  In fact, these
lecture notes have all been typeset using \LaTeX.  \textsc{MathML} is the part of \textsc{Html} that
deals with the representation of mathematical formul\ae.  As \LaTeX\ provides a very rich
document markup language and we can only afford to spend a few hours on this exercise, we confine
ourselves to a small subset of \LaTeX.  Figure \ref{fig:input.tex} on page \pageref{fig:input.tex}
shows the example input file that we want to transform in \textsc{Html}.  If this example file is
typeset using \LaTeX, it is displayed as shown in Figure \ref{fig:input.pdf} on page
\pageref{fig:input.pdf}.  The program that you are
going to develop should transform the \LaTeX\ input file into an \textsc{Html} file.  For your
convenience, all these files are available in the github directory 
\\[0.2cm]
\hspace*{1.3cm}
\href{https://github.com/karlstroetmann/Formal-Languages/tree/master/JFlex/LaTeX2HTML}{\texttt{JFlex/LaTeX2HTML}}.

\begin{figure}[!ht]
  \centering
\begin{verbatim}
    \documentclass{article}
    \begin{document}
    The sum of the squares of the first $n$ natural numbers is given as:
    $$ \sum\limits_{i=1}^{n} i^{2} = \frac{1}{6} \cdot n \cdot (n+1) \cdot (2\cdot n + 1). $$
    According to Pythagoras, the length of the hypotenuse of a right triangle is
    the square root of the squares of the length of the two catheti:
    $$ c = \sqrt{a^{2} + b^{2}}.  $$
    The area of a circle is given as 
    $$  A = \pi \cdot r^{2},   $$ 
    while its circumference satisfies
    $$ C = 2 \cdot \pi \cdot r.  $$
    \end{document}
    \end{verbatim}
  \caption{An example \LaTeX\ input file.}
  \label{fig:input.tex}
\end{figure}

\begin{figure}[!ht]
  \centering
  \framebox{
  \begin{minipage}{0.8\linewidth}
    The sum of the squares of the first $n$ natural numbers is given as:
    $$ \sum_{i=1}^{n} i^{2} = \frac{1}{6} \cdot n \cdot (n+1) \cdot (2\cdot n + 1). $$
    According to Pythagoras, the length of the hypotenuse of a right triangle is
    the square root of the squares of the length of the two catheti:
    $$ c = \sqrt{a^{2} + b^{2}}.  $$
    The area $A$ of a circle is given as 
    $$  A = \pi \cdot r^{2},   $$ 
    while its circumference satisfies
    $$ C = 2 \cdot \pi \cdot r.  $$   
  \end{minipage}}
  \caption{Output produced by the \LaTeX\ file shown in Figure \ref{fig:input.tex}}
  \label{fig:input.pdf}
\end{figure}

In order to do this exercise, you have to understand a little bit about \LaTeX\ and about 
\textsc{MathML}.  In the following, we discuss those features of these two language that are needed.
\begin{enumerate}
\item A \LaTeX\ input file has the following structure:
      \begin{enumerate}
      \item The first line list the type of the document.  In our example, it reads
            \\[0.2cm]
            \hspace*{1.3cm}
            \texttt{\symbol{92}documentclass\{article\}}.
            \\[0.2cm]
            This line will be transformed into the following \textsc{Html}:
            \begin{verbatim}
    <html>
    <head>
    <script type="text/javascript"
    src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
    </script>
            \end{verbatim}
            Here, the \texttt{<script>} tag is necessary in order for the \textsc{MathML} 
            to be displayed correctly.
      \item The next line has the form:
            \\[0.2cm]
            \hspace*{1.3cm}
            \texttt{\symbol{92}begin\{document\}}
            \\[0.2cm]
            This line precedes the content and should be translated into the tag
            \\[0.2cm]
            \hspace*{1.3cm}
            \texttt{<body>}.
      \item After that, the \LaTeX\ file contains text that contains mathematical formula.
      \item The \LaTeX\ input file finishes with a line of the form
            \\[0.2cm]
            \hspace*{1.3cm}
            \texttt{\symbol{92}end\{document\}}.
            \\[0.2cm]
            This line should be translated into the tags
            \\[0.2cm]
            \hspace*{1.3cm}
            \texttt{</body></html>}.
      \end{enumerate}
\item In \LaTeX, an inline formula is started and ended with a single dollar symbol
      ``\texttt{\symbol{36}}''.  
      In \textsc{MathML}, an inline formula is written as
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{<math xmlns="http://www.w3.org/1998/Math/MathML" display='inline'>$\cdots$</math>}.
      \\[0.2cm]
      Here, I have used ``$\cdots$'' to represent the mathematical content of the formula.
\item In \LaTeX, a formula that is displayed in its own line is started and ended with the string
      ``\texttt{\symbol{36}\symbol{36}}''.  
      In \textsc{MathML}, these formul\ae\ are called \blue{block formul\ae} and are written as
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{<math xmlns="http://www.w3.org/1998/Math/MathML" display='block'>$\cdots$</math>}.
      \\[0.2cm]
      Again, I have used ``$\cdots$'' to represent the mathematical content of the formula.
\item While in \LaTeX\ a mathematical variable does not need any special markup, in \textsc{MathMl}
      a mathematical variable is written using the tags 
      \texttt{<mi>} and \texttt{</mi>}.  For example, the mathematical variable $n$ is written as    
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{<mi>n</mi>}.
\item While in \LaTeX\ a number does not need any special markup, in \textsc{MathMl}
      a number is written using the tags 
      \texttt{<mn>} and \texttt{</mn>}.  For example, the number $3.14149$ is written as    
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{<mn>3.14159</mn>}.
\item In \LaTeX\ the mathematical constant $\pi$ is written using the command ``\texttt{\symbol{92}pi}''.
      In \textsc{MathMl}, we have to make use of the \textsc{Html} entity ``\texttt{\&pi;}'' and
      hence we would write $\pi$ as
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{<mn>\&pi;</mn>}.
\item In \LaTeX\ the multiplication operator ``$\cdot$'' is written using the command ``\texttt{\symbol{92}cdot}''.
      In \textsc{MathMl}, we have to make use of the \textsc{Html} entity ``\texttt{\&sdot;}'' and
      hence we would write ``$\cdot$'' as
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{<mop>\&sdot;</mop>}.
\item While in \LaTeX\ most operator symbols stand for themselves, in \textsc{MathMl}
      an operator is surrounded by the tags 
      \texttt{<mop>} and \texttt{</mop>}.  For example, the operator $+$ is written as    
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{<mop>+</mop>}.
\item In \LaTeX, raising an expression $e$ to the $n$th power is done using the operator
      ``\texttt{\symbol{94}}''.  Furthermore, the exponent should be enclosed in the curly braces
      ``\texttt{\{}'' and ``\texttt{\}}''.  For example, the code to produce the term $x^2$ is
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{x\symbol{94}\{2\}}.
      \\[0.2cm]
      In \textsc{MathMl}, raising an expression to a power is achieved using the tags
      \texttt{<msup>} and \texttt{</msup>}.  For example, in order to display the term $x^2$, we
      have to write  
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{<msup><mi>x</mi><mn>2</mn></msup>}.
\item In \LaTeX, taking the square root of an expression is done using the command
      ``\texttt{\symbol{92}sqrt}''.  The argument has to be enclosed in curly braces.
      For example, in order to produce the output $\sqrt{a+b}$, we have to write
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{\symbol{92}sqrt\{a+b\}}.
      \\[0.2cm]
      In \textsc{MathMl}, taking the square root makes use of the tags \texttt{<msqrt>} 
      and \texttt{</msqrt>}.  The example shown above can be written as
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{<msqrt><mi>a</mi><mop>+</mop><mi>b</mi></msqrt>}.
\item In \LaTeX, writing a fraction is done using the command
      ``\texttt{\symbol{92}frac}''.  This command takes two arguments, the numerator and the
      denominator.  Both of these have to be enclosed in curly braces.
      For example, in order to produce the output $\frac{a+b}{2}$, we have to write
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{\symbol{92}frac\{a+b\}\{2\}}.
      \\[0.2cm]
      In \textsc{MathMl}, a fraction is created via the tags \texttt{<mfrac>} 
      and \texttt{</mfrac>}.  Additionally, if the arguments contain more than a single element,
      each of them has to be enclosed in the tags \texttt{<mrow>} and \texttt{</mrow>}.
      The example shown above can be written as
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{<mfrac><mrow><mi>a</mi><mop>+</mop><mi>b</mi></mrow><mn>2</mn></mfrac>}.
\item In \LaTeX, writing a sum is done using the command
      ``\texttt{\symbol{92}sum\symbol{92}limits}''.  
      This command takes two arguments:  The first argument gives the indexing variable together
      with its lower bound, while the second argument gives the upper bound.  The first argument
      is started using the string ``\texttt{\_\{}'' and ended using the string ``\texttt{\}}'',
      while the second argument is started using the string ``\texttt{\symbol{94}\{}'' and ended using the
      string ``\texttt{\}}''.  For example, in order to produce the output 
      \\[0.2cm]
      \hspace*{1.3cm}
      $\displaystyle\sum\limits_{i=1}^{n} i$,
      \\[0.2cm]
      we have to write
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{\symbol{92}sum\symbol{92}limits\_\{i=1\}\symbol{94}\{n\} i}.
      \\[0.2cm]
      In \textsc{MathMl}, a sum with lower and upper limits is created via the tags
      \texttt{<munderover>} and \texttt{</munderover>} and the \textsc{Html} entity ``\texttt{\&sum}''.
      The tag \texttt{munderover} takes three arguments:
      \begin{enumerate}
      \item The first argument is the operator, so in this case it is the entity ``\texttt{\&sum}''.
      \item The second argument initializes the indexing variable of the sum.
      \item The third argument provides the upper bound.
      \end{enumerate}
      The second argument usually contains more than a single item and therefore has to be enclosed 
      in the tags \texttt{<mrow>} and \texttt{</mrow>}.
      Hence, the example shown above would be written as follows: 
    \begin{verbatim}
    <munderover>
        <mo>&sum;</mo>
        <mrow>
            <mi>i</mi> <mo>=</mo> <mn>1</mn>
        </mrow>
        <mi>n</mi>
    </munderover>
    \end{verbatim}
\end{enumerate}
In order to cut the time necessary to complete this exercise, I have provided a \textsc{Java} class
\texttt{HtmlWriter} that contains a number of useful static methods.  This file is available at
\\[0.2cm]
\hspace*{1.3cm}
\href{https://github.com/karlstroetmann/Formal-Languages/tree/master/JFlex/LaTeX2HTML/HtmlWriter.java}{\texttt{JFlex/LaTeX2HTML/HtmlWriter.java}}.
\\[0.2cm] 
Furthermore, the \texttt{github} directory \texttt{JFlex/LaTeX2HTML} already contains a \texttt{Makefile}.
Additionally, the directory contains the file
\\[0.2cm]
\hspace*{1.3cm}
\href{https://github.com/karlstroetmann/Formal-Languages/tree/master/JFlex/LaTeX2HTML/input.html}{\texttt{JFlex/LaTeX2HTML/input.html}}
\\[0.2cm]
which shows the result of converting the input file ``\texttt{input.tex}'' into \textsc{Html}.
Next, there is a file \texttt{State.java} containing an enumeration that I have found useful for my
solution of the problem.

\remarkEng
The most important problem that you have to solve is the following:  Once you encounter a closing brace
``\texttt{\}}'' you have to know whether this brace closes the argument of a square root, a
fraction, a sum, or an exponent.  You should be aware that, for example, square roots and fractions
can be nested.  Hence, it is not enough to have a single variable that remembers whether you are
parsing, say, a square root or a fraction.  Instead, every time you encounter a string like, e.g.
\\[0.2cm]
\hspace*{1.3cm}
\texttt{\symbol{92}sqrt\{} \quad or \quad \texttt{\symbol{92}frac\{},
\\[0.2cm]
you should store the current state on a stack and set the new state according to whether you have just seen the
keyword ``\texttt{\symbol{92}frac}'' or ``\texttt{\symbol{92}sqrt}'' or whatever else caused the
curly brace to be opened.  When you encounter a closing brace ``\texttt{\}}'', you should 
restore the state to its previous value by looking up this value from the stack.  The github directory
\texttt{JFlex/LaTeX2HTML} already contains both the interface \texttt{Stack.java} as well as the
class \texttt{ArrayStack.java} implementing this interface.
\eox




%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "formal-languages.tex"
%%% End: 

\section{Code Generation}
Next, we discuss the generation of code.  We structure our representation by discussing the code generation for
arithmetic expressions, Boolean expression, statements, and function definitions separately. 

\subsection{Translation of Arithmetic Expressions}
Given an arithmetic expression $e$, the translation of $e$ is supposed to generate some code that, when
executed, places the result of evaluating the expression $e$ onto the stack.  To this end we define a function
\mytt{compile\_expr} that has the following signature:
\\[0.2cm]
\hspace*{1.3cm}
$\mytt{compile\_expr}: \textsl{Expr} \times \textsl{SymbolTable} \times \textsl{ClassName} \rightarrow 
                 \bigl\langle\textsl{List}\mytt{[}\textsl{AsmCmd}\mytt{]}, \mathbb{N}\bigr\rangle.$
\\[0.2cm]
A call of this function has the form
\\[0.2cm]
\hspace*{1.3cm}
$\mytt{compile\_expr}(\mytt{expr}, \mytt{st}, \mytt{name})$.
\\[0.2cm]
The interpretation of the arguments is as follows:
\begin{enumerate}[(a)]
\item \mytt{expr} is the arithmetic expression that is to be translated into assembler code.
\item \mytt{st} is the \blue{symbol table}: \index{symbol table} Concretely, this is a dictionary that maps
      the variable names to their position in the local variable frame.  For example, if \squoted{x} is a
      variable that occupies the third slot in the local variable frame, then we have
      \\[0.2cm]
      \hspace*{1.3cm}
      \mytt{st['x'] = 2},
      \\[0.2cm]
      because the first variable in the local variable frame has index 0.  We will discuss later how the 
      positions of the variables in the local variable frame is assigned.
\item \mytt{name} is the name of the class that is to be used by our compiler.

      As we generate \textsl{Java} assembler and in \textsl{Java} every function has to be a part of a class,
      all functions that we create have to be static functions that are defined inside the \textsl{Java}
      \mytt{.class} file that is generated.  The parameter \mytt{name} specifies the name of this class.

      The argument \mytt{name} is only needed when function calls are translated.
\end{enumerate}
The function \mytt{compile\_expr} returns a pair.  
\begin{enumerate}[(a)]
\item The first component of this pair is a list of \textsl{Java} 
      assembler commands that adhere to the syntax recognized by \textsl{Jasmin}.  In general, when the
      expression that is translated is complex, the execution of these assembler commands might need
      considerable room on the stack.  However, it has to be guaranteed that when the execution of theses
      commands finishes, the stack is back to its original height plus one because the net 
      effect of executing these commands must be to put the value of the expression on the stack.
\item The second component of the return value of \mytt{compile\_expr} is a natural number.
      This natural number tells us how much the stack might grow when \mytt{expr} is evaluated.
      This information is needed because the \textsl{Java} virtual machine needs this information in advance:
      In \textsl{Java}, every function has to declare how much space it might use on the stack.
      This declaration is done using the pseudo assembler command \mytt{.limit}.  Controlling the 
      maximum height of the stack is a security feature of \textsl{Java} that prevents those exploits that
      utilize stack overflows.
\end{enumerate}
In the following, we discuss the evaluation of the different arithmetic expressions one by one.


\subsubsection{Translation of a Variable}
If the expression that is to be compiled is a variable $v$, we have to load this variable onto the stack using
the command \mytt{iload}.  This command has one parameter which is the index of the variable on the local
variable frame.  This index is stored in the symbol table \mytt{st}.  Since we just need one entry on the
stack to store the variable we have
\\[0.2cm]
\hspace*{1.3cm}
$\mytt{compile\_expr}(v, \mytt{st}, \mytt{name}) = 
 \bigl\langle\mytt{[}\;\; \mytt{iload}\; \mytt{st[}v\mytt{]}\; \mytt{]}, \; 1\bigr\rangle$ \quad
 if $v$ is a variable.
\\[0.2cm]
The code for translating a variable is shown in Figure \ref{fig:Compiler.ipynb:compile:var} on page
\pageref{fig:Compiler.ipynb:compile:var}.

\begin{figure}[!ht]
\centering
\begin{minted}[ frame         = lines, 
                 framesep      = 0.3cm, 
                 firstnumber   = 1,
                 bgcolor       = sepia,
                 numbers       = left,
                 numbersep     = -0.2cm,
                 xleftmargin   = 0.8cm,
                 xrightmargin  = 0.8cm,
               ]{python3}
    def compile_expr(expr, st, class_name):
        if isinstance(expr, str):
            return [f'iload {st[expr]}'], 1
        ...
\end{minted}
\vspace*{-0.3cm}
\caption{Translation of a variable.}
\label{fig:Compiler.ipynb:compile:var}
\end{figure}

\subsubsection{Translation of a Constant}
We can load a constant $c$ onto the stack using the assembler command 
\\[0.2cm]
\hspace*{1.3cm}
\mytt{ldc} $c$.
\\[0.2cm]
As we only need the room to store $c$ on the stack, we have
\\[0.2cm]
\hspace*{1.3cm}
$\mytt{compile\_expr}(c, \mytt{st}, \mytt{name}) = 
 \bigl\langle\mytt{[}\;\; \mytt{ldc}\; c \;\mytt{]}, \; 1\bigr\rangle$ \quad
 if $c$ is a constant.
\\[0.2cm]
The code for translating a constant is shown in Figure \ref{fig:Compiler.ipynb:compile:const} on page
\pageref{fig:Compiler.ipynb:compile:const}.

\begin{figure}[!ht]
\centering
\begin{minted}[ frame         = lines, 
                 framesep      = 0.3cm, 
                 firstnumber   = last,
                 bgcolor       = sepia,
                 numbers       = left,
                 numbersep     = -0.2cm,
                 xleftmargin   = 0.8cm,
                 xrightmargin  = 0.8cm,
               ]{python3}
    def compile_expr(expr, st, class_name):
        ...
        elif expr[0] == 'Number':
            _, n = expr
            return [f'ldc {n}'], 1
        ...
\end{minted}
\vspace*{-0.3cm}
\caption{Translation of a variable.}
\label{fig:Compiler.ipynb:compile:const}
\end{figure}

\subsubsection{Translation of an Arithmetic Operator}
In order to translate an expression of the form
\[ \textsl{lhs} \quoted{+} \textsl{rhs} \]
into assembler code, we first have to recursively translate the expressions \textsl{lhs} and
\textsl{rhs} into assembler code.  Later, when this code is executed the values of the expressions
\textsl{lhs} und \textsl{rhs} are placed on the stack.  We add these values using the command \mytt{iadd}.
If the evaluation of \textsl{lhs} needs $s_1$ words on the stack and the evaluation of \textsl{rhs} needs $s_2$
words on the stack, then the evaluation of $\textsl{lhs} + \textsl{rhs}$ needs 
\\[0.2cm]
\hspace*{1.3cm}
$\max(s_1, 1 + s_2)$
\\[0.2cm]
words on the stack, because when \textsl{rhs} is evaluated, the value of \textsl{lhs} occupies already one position
on the stack and hence the evaluation of \textsl{rhs} can only use the memory cells that are above the position
where \textsl{lhs} is stored. Therefore, the compilation of $\textsl{lhs} + \textsl{rhs}$ can be specified as
follows:
\\[0.2cm]
\hspace*{1.3cm}
$
\begin{array}[t]{cll}
        & \mytt{compile\_expr}(\textsl{lhs}, \mytt{st}, \mytt{name}) = \pair(L_1, s_1)  \\[0.1cm]
\wedge  & \mytt{compile\_expr}(\textsl{rhs}, \mytt{st}, \mytt{name}) = \pair(L_2, s_2)  \\[0.1cm]
\rightarrow & \mytt{compile\_expr}(\textsl{lhs} + \textsl{rhs}, \mytt{st}, \mytt{name}) = 
            \bigl\langle L1 + L2 + \mytt{[}\; \mytt{iadd} \;\mytt{]}, \max(s_1, 1+s_2) \bigr\rangle.
\end{array}$
\\[0.2cm]
Figure \ref{fig:Compiler.ipynb:compile:iadd} on page \pageref{fig:Compiler.ipynb:compile:iadd} shows how the
translation of arithmetic operators is implemented.  The translation of subtraction, multiplication, and
division is similar.

\begin{figure}[!ht]
\centering
\begin{minted}[ frame         = lines, 
                 framesep      = 0.3cm, 
                 firstnumber   = last,
                 bgcolor       = sepia,
                 numbers       = left,
                 numbersep     = -0.2cm,
                 xleftmargin   = 0.3cm,
                 xrightmargin  = 0.3cm,
               ]{python3}
    def compile_expr(expr, st, class_name):
        ...
        elif expr[0] in  ['+', '-', '*', '/', '%']:
            op, lhs, rhs = expr
            L1, sz1 = compile_expr(lhs, st, class_name)
            L2, sz2 = compile_expr(rhs, st, class_name)
            OpToCmd = { '+': 'iadd', '-': 'isub', '*': 'imul', '/': 'idiv', '%': 'irem' }
            Cmd     = indent(OpToCmd[op])
            return L1 + L2 + [Cmd], max(sz1, 1 + sz2)
        ...
\end{minted}
\vspace*{-0.3cm}
\caption{Translation of the addition of expressions.}
\label{fig:Compiler.ipynb:compile:iadd}
\end{figure}


\subsubsection{Translation of a Function Call}
In order to translate a function call of the form  $f(a_1, \cdots, a_n)$ we first have to translate the
arguments $a_1$, $\cdots$, $a_n$.  Then there are two cases:
\begin{enumerate}
\item $f$ is a user defined function.  In this case, the byte code treats $f$ as a static function of the
      class \mytt{class\_name}.  This static function can be called using the assembler command
      \mytt{invokestatic}.  In order to calculate the stack size that needs to be reserved for the evaluation
      of  $f(a_1, \cdots, a_n)$, let us assume that we have
      \\[0.2cm]
      \hspace*{1.3cm}
      $\mytt{compile\_expr}(a_i, \mytt{st}, \mytt{class\_name}) = \pair(L_i, s_i)$,
      \\[0.2cm]
      i.e.~evaluation of the $i^\mathrm{th}$ argument is done by the list of assembler commands $L_i$ and
      needs a stack size of $s_i$.  As we are evaluating the arguments $a_i$ in the order from $a_1$ to $a_n$,
      the evaluation of $a_i$ needs a stack size of $i-1 + s_i$, since the results from the evaluation of
      the arguments $a_1$, $\cdots$, $a_{i-1}$ are already placed on the stack.  Therefore, if we define
      \\[0.2cm]
      \hspace*{1.3cm}
      $s := \max(s_1, 1 + s_2, \cdots, i - 1 + s_i, \cdots, n-1 + s_n)$,
      \\[0.2cm]
      then $s$ is the total amount of stack size needed to evaluate the arguments.  Furthermore, let us define
      the \blue{signature} \mytt{fs} of the function $f$ as the string
      \\[0.2cm]
      \hspace*{1.3cm}
      $\mytt{fs} := \mytt{class\_name/}\mytt{f(}\underbrace{\mytt{I}\cdots\mytt{I}}_{n}\mytt{)I}$.
      \\[0.2cm]
      Then we can define the
      value of
      $\mytt{compile\_expr}\bigl(f(a_1,\cdots,a_n), \mytt{st}, \mytt{class\_name}\bigr)$ as follows:
      \\[0.2cm]
      \hspace*{0.8cm}
      $\mytt{compile\_expr}\bigl(f(a_1,\cdots,a_n), \mytt{st}, \mytt{class\_name}\bigr) :=
      \bigl\langle L_1 + \cdots + L_n + \mytt{[} \; \mytt{invokestatic}\; \mytt{fs} \;\mytt{]}, \max(s,1)\bigr\rangle$.
\item If $f$ is the function \mytt{println}, then \textsl{Jasmin} treats the function $f$ as a method of the
      predefined \textsl{Java} object \mytt{java.lang.System.out}.
      This method can be invoked using the assembler command
      \mytt{invokevirtual}.  As before, let us assume that we have
      \\[0.2cm]
      \hspace*{1.3cm}
      $\mytt{compile\_expr}(a_i, \mytt{st}, \mytt{class\_name}) = \pair(L_i, s_i)$.
      \\[0.2cm]
      This time, we have to start by putting the object \mytt{java.lang.System.out} onto the stack before we
      can evaluate any of the arguments.  Therefore, in order to calculate the stack size we now define
      \\[0.2cm]
      \hspace*{1.3cm}
      $s := \max(1 + s_1, 2 + s_2, \cdots, i - 1 + s_i, \cdots, n + s_n)$.
      \\[0.2cm]
      In this case we have to define the \blue{signature} \mytt{fs} of $f$ as the string
      \\[0.2cm]
      \hspace*{1.3cm}
      $\mytt{fs} := \mytt{java/io/PrintStream/println(}\underbrace{\mytt{I}\cdots\mytt{I}}_{n}\mytt{)V}$.
      \\[0.2cm]
      Furthermore, we define the command \mytt{gs} for putting the object \mytt{java.lang.System.out} onto the
      stack as 
      \\[0.2cm]
      \hspace*{1.3cm}
      $\mytt{gs} :=  \mytt{getstatic java/lang/System/out Ljava/io/PrintStream;}$.
      \\[0.2cm]
      Then we can define the
      value of
      $\mytt{compile\_expr}\bigl(f(a_1,\cdots,a_n), \mytt{st}, \mytt{class\_name}\bigr)$ as follows:
      \\[0.2cm]
      \hspace*{1.3cm}
      $\mytt{compile\_expr}\bigl(f(a_1,\cdots,a_n), \mytt{st}, \mytt{class\_name}\bigr) := \\[0.1cm]
      \hspace*{2.8cm} \bigl\langle \mytt{[} \;\mytt{gs} \;\mytt{]} + L_1 + \cdots + L_n +
                   \mytt{[} \; \mytt{invokestatic}\; \mytt{fs} \;\mytt{]}, \max(s,1)\bigr\rangle$.
      \end{enumerate}

Figure \ref{fig:Compiler.ipynb:compile:iadd} on page \pageref{fig:Compiler.ipynb:compile:iadd} shows how the
translation of function calls is implemented.  

\begin{figure}[!ht]
\centering
\begin{minted}[ frame         = lines, 
                 framesep      = 0.3cm, 
                 firstnumber   = last,
                 bgcolor       = sepia,
                 numbers       = left,
                 numbersep     = -0.2cm,
                 xleftmargin   = 0.8cm,
                 xrightmargin  = 0.8cm,
               ]{python3}
    def compile_expr(expr, st, class_name):
        ...
        elif expr[0] == 'call' and expr[1] == 'println':
            _, _, *args = expr
            CmdLst    = ['getstatic java/lang/System/out Ljava/io/PrintStream;')
            stck_size = 0
            cnt       = 0
            for arg in args:
                L, sz_arg = compile_expr(arg, st, class_name)
                stck_size = max(stck_size, cnt + 1 + sz_arg)
                CmdLst   += L
                cnt      += 1
            CmdLst += [f'invokevirtual java/io/PrintStream/println({"I"*cnt})V']
            return CmdLst, stck_size
        elif expr[0] == 'call' and expr[1] != 'println':
            _, f, *args = expr
            CmdLst    = []
            stck_size = 0
            cnt       = 0
            for arg in args:
                L, sz_arg = compile_expr(arg, st, class_name)
                stck_size = max(stck_size, cnt + sz_arg)
                CmdLst   += L
                cnt      += 1
            CmdLst += [f'invokestatic {class_name}/{f}({"I"*cnt})I']
            return CmdLst, max(stck_size, 1)
        ...
\end{minted}
\vspace*{-0.3cm}
\caption{Translation of function calls.}
\label{fig:Compiler.ipynb:compile:call}
\end{figure}

\subsection{Translation of Boolean Expressions}
Boolean expressions are build from equations and inequations using the logical operators
\qote{!} (logical not), \qote{\&\&} (logical and), and \qote{||} (logical or).
To compile Boolean expressions we define a function
\mytt{compile\_bool} that has the following signature:
\\[0.2cm]
\hspace*{1.3cm}
$\mytt{compile\_bool}: \textsl{BoolExpr} \times \textsl{SymbolTable} \times \textsl{ClassName} \rightarrow 
                 \bigl\langle\textsl{List}\mytt{[}\textsl{AsmCmd}\mytt{]}, \mathbb{N}\bigr\rangle.$
\\[0.2cm]
The interpretation of the arguments is similar to the interpretation of the arguments
of the function \mytt{compile\_expr}.  
When we execute the list of assembler commands that result from the compilation of a Boolean expression, we
expect that the execution of theses commands either puts the number $1$ (representing \mytt{True}) or the
number $0$ (representing \mytt{False}) onto the stack. 
We start our discussion of the function \mytt{compile\_bool} with the translation of equations.

\subsubsection{Translation of Equations}
In the \textsl{Java} virtual machine, the logical values \mytt{True} and \mytt{False} are represented by
the integers $1$ and $0$, respectively.  Therefore, the code produced from translating an equation of the form 
\[ \textsl{lhs}\; \mytt{==} \;\textsl{rhs} \]
should either place the number $1$ or $0$ onto the stack: If the value of \textsl{lhs} is equal to the value of
\textsl{rhs}, the number $1$ has to be put on the stack, otherwise the value $0$ has to be put onto the stack.
Let us assume that we have
\\[0.2cm]
\hspace*{1.3cm}
$\mytt{compile\_expr}(\textsl{lhs}, \mytt{st}, \mytt{class\_name}) = \pair(L_1, s_1)$ \quad and \quad
$\mytt{compile\_expr}(\textsl{rhs}, \mytt{st}, \mytt{class\_name}) = \pair(L_2, s_2)$.
\\[0.2cm]
Then the stack size needed for evaluating the equation $\textsl{lhs}\; \mytt{==} \;\textsl{rhs}$ is given by
the expression 
\\[0.2cm]
\hspace*{1.3cm}
$\max(s_1, 1 + s_2)$
\\[0.2cm]
and the function \mytt{compile\_bool} can be specified as follows:
\[
   \begin{array}[t]{lcccl}
   \textsl{compile\_bool}(\textsl{lhs}\;\mytt{==}\;\textsl{rhs}, \mytt{st}, \mytt{class\_name}) & = & 
         \bigl\langle & \quad & L_1  \\
   &&& + & L_2 \\
   &&& + & [ \;\mytt{if\_icmpeq}\; \textsl{true} \; ]  \\
   &&& + & [ \;\mytt{bipush}\;0\; ]  \\
   &&& + & [ \;\mytt{goto}\;\textsl{next}\; ]  \\
   &&& + & [ \;\textsl{true}\mytt{:}\; ]  \\
   &&& + & [ \;\mytt{bipush}\;1\; ]  \\
   &&& + & [ \;\textsl{next}\mytt{:}\; ], \qquad\qquad s \bigr\rangle
   \end{array}
\]
Here, \textsl{true} and \textsl{next} have to be new labels that do not occur elsewhere in the code for the
function that is compiled.  Let me explain this equation in detail:
\begin{enumerate}
\item $L_1$ and $L_2$ are the lists of assembler commands that evaluate  \textsl{lhs} and \textsl{rhs}, respectively.
\item Executing $L_1$ and $L_2$ leaves two values on the stack.  These values are then compared using the
      assembler command \mytt{if\_icmpeq}.  If these value are the same, execution proceeds at the label
      \textsl{true}.
\item Otherwise execution commences with the next instruction and hence the value $0$ is pushed onto the stack.
\item Next, the control flow jumps to the label \textsl{next}, which is at the end of the generated
      list of assembler commands.  Hence, in this case the execution of equation
      $\textsl{lhs}\; \mytt{==} \;\textsl{rhs}$ is finished. 
\item If the values of \textsl{lhs} and \textsl{rhs} are the same, the number $1$
      is pushed onto the stack.
\end{enumerate}
The translation of a negated equation of the form
\[ \textsl{lhs}\;\mytt{!=}\;\textsl{rhs} \]
is similar to the translation of an equation:  We only have to replace the command \mytt{if\_icmpeq} with the
command \mytt{if\_icmpne}.  Similarly, if the inequation has the form
\[ \textsl{lhs}\;\mytt{<=}\;\textsl{rhs} \]
we have to replace the command \mytt{if\_icmpeq} with the command \mytt{if\_icmple}.
If the inequation has the form
\[ \textsl{lhs}\;\mytt{>=}\;\textsl{rhs} \]
we have to replace the command \mytt{if\_icmpeq} with the command \mytt{if\_icmpge}.
If the inequation has the form
\[ \textsl{lhs}\;\mytt{<}\;\textsl{rhs} \]
we have to replace the command \mytt{if\_icmpeq} with the command \mytt{if\_icmplt}.
If the inequation has the form
\[ \textsl{lhs}\;\mytt{>}\;\textsl{rhs} \]
we have to replace the command \mytt{if\_icmpeq} with the command \mytt{if\_icmpgt}.
Figure \ref{fig:Compiler.ipynb:compile:eq} on page \pageref{fig:Compiler.ipynb:compile:eq} shows how the
translation of equations and inequations is implemented.  

\begin{figure}[!ht]
\centering
\begin{minted}[ frame         = lines, 
                 framesep      = 0.3cm, 
                 firstnumber   = 1,
                 bgcolor       = sepia,
                 numbers       = left,
                 numbersep     = -0.2cm,
                 xleftmargin   = 0.8cm,
                 xrightmargin  = 0.8cm,
               ]{python3}
    def compile_bool(expr, st, class_name):
        if expr[0] in ['==', '!=', '<=', '>=', '<', '>']:
            OpToCmd = { '==': 'if_icmpeq', 
                        '!=': 'if_icmpne', 
                        '<=': 'if_icmple',
                        '>=': 'if_icmpge',
                        '<' : 'if_icmplt',
                        '>' : 'if_icmpgt'
                      }
            op, lhs, rhs = expr
            L1, sz1    = compile_expr(lhs, st, class_name)
            L2, sz2    = compile_expr(rhs, st, class_name)
            true_label = new_label()
            next_label = new_label()
            CmdLst     = L1 + L2
            cmd        = OpToCmd[op]
            CmdLst    += [indent(cmd + ' ' + true_label)]
            CmdLst    += [indent('bipush 0')]
            CmdLst    += [indent('goto ' + next_label)]
            CmdLst    += [' ' * 4 + true_label + ':']
            CmdLst    += [indent('bipush 1')]
            CmdLst    += [' ' * 4 + next_label + ':']
            return CmdLst, max(sz1, 1 + sz2)
            ...
\end{minted}
\vspace*{-0.3cm}
\caption{Translation of equations.}
\label{fig:Compiler.ipynb:compile:eq}
\end{figure}

\subsubsection{Translation of Binary Boolean Operators}
In order to translate an expression of the form
\[ \textsl{lhs} \;\mytt{\&\&}\; \textsl{rhs} \]
into assembler code, we first have to recursively translate the expressions \textsl{lhs} and
\textsl{rhs} into assembler code.  Later, when this code is executed the values of the expressions
\textsl{lhs} und \textsl{rhs} are placed on the stack.  We combine these values using the command \mytt{iand}.
If the evaluation of \textsl{lhs} needs $s_1$ words on the stack and the evaluation of \textsl{rhs} needs $s_2$
words on the stack, then the evaluation of $\textsl{lhs} + \textsl{rhs}$ needs 
\\[0.2cm]
\hspace*{1.3cm}
$\max(s_1, 1 + s_2)$
\\[0.2cm]
words on the stack, because when \textsl{rhs} is evaluated, the value of \textsl{lhs} occupies already one position
on the stack and hence the evaluation of \textsl{rhs} can only use the memory cells that are above the position
where \textsl{lhs} is stored. Therefore, the compilation of $\textsl{lhs} \;\mytt{\&\&}\; \textsl{rhs}$ can be
specified as follows:
\\[0.2cm]
\hspace*{1.3cm}
$
\begin{array}[t]{cll}
        & \mytt{compile\_bool}(\textsl{lhs}, \mytt{st}, \mytt{name}) = \pair(L_1, s_1)  \\[0.1cm]
\wedge  & \mytt{compile\_bool}(\textsl{rhs}, \mytt{st}, \mytt{name}) = \pair(L_2, s_2)  \\[0.1cm]
\rightarrow & \mytt{compile\_bool}(\textsl{lhs} + \textsl{rhs}, \mytt{st}, \mytt{name}) = 
            \bigl\langle L1 + L2 + \mytt{[}\; \mytt{iand} \;\mytt{]}, \max(s_1, 1+s_2) \bigr\rangle.
\end{array}$
\\[0.2cm]
The translation of an expression of the form
\[ \textsl{lhs} \;\mytt{||}\; \textsl{rhs} \]
is similar:  Instead of using the command \mytt{iand} we have to use the command \mytt{ior} instead.
Figure \ref{fig:Compiler.ipynb:compile:iand} on page \pageref{fig:Compiler.ipynb:compile:iand} shows how the
translation of binary logical operators is implemented.

\begin{figure}[!ht]
\centering
\begin{minted}[ frame         = lines, 
                 framesep      = 0.3cm, 
                 firstnumber   = last,
                 bgcolor       = sepia,
                 numbers       = left,
                 numbersep     = -0.2cm,
                 xleftmargin   = 0.8cm,
                 xrightmargin  = 0.8cm,
               ]{python3}
    def compile_expr(expr, st, class_name):
        ...
        elif expr[0] in ['&&', '||']:
            op, lhs, rhs = expr
            OpToCmd      = { '&&': iand, '||': 'ior' }
            L1, sz1      = compile_bool(lhs, st, class_name)
            L2, sz2      = compile_bool(rhs, st, class_name)
            cmd          = OpToCmd[op]
            CmdLst       = L1 + L2 + [indent(cmd)]
            return CmdLst, max(sz1, 1 + sz2)
        ...
\end{minted}
\vspace*{-0.3cm}
\caption{Translation of binary logical operators.}
\label{fig:Compiler.ipynb:compile:iand}
\end{figure}

It should be noted that our translation of the binary logical operators is different from
what happens in the language \mytt{C}.  In \mytt{C}, if an expression of the form
\\[0.2cm]
\hspace*{1.3cm}
\textsl{lhs} \mytt{\&\&} \textsl{rhs}
\\[0.2cm]
is evaluated, the evaluation is stopped as soon the evaluation of \textsl{lhs}
returns $0$ because then there is no point to evaluate \textsl{rhs}, since if the value of \textsl{lhs} is $0$,
the result of the expression $\textsl{lhs} \;\mytt{\&\&}\; \textsl{rhs}$ is $0$, independent from the value of
the expression \textsl{rhs}. 

\subsubsection{Translation of Negations}
The translation of an expression of the form $\mytt{!}\textsl{expr}$ is not as straightforward as the
translation of conjunctions and disjunctions.  The reason is that \textsl{Jasmin} has no assembler command of
the form \mytt{inot} that negates a logical value.  But there is another way: Since we represent the truth
values as $0$ and $1$, we can specify negation arithmetically as follows:
\[ \mytt{!}x = 1 - x. \]
Therefore, if we have
\\[0.2cm]
\hspace*{1.3cm}
$\mytt{compile\_bool}(\textsl{arg}, \mytt{st}, \mytt{class\_name}) = \pair(L, s)$
\\[0.2cm]
we can define:
\\[0.2cm]
\hspace*{1.3cm}
$\mytt{compile\_bool}(\mytt{!}\textsl{arg}, \mytt{st}, \mytt{class\_name})
= \bigl\langle \mytt{[bipush 1]} + L + \mytt{[isub]}, 1 + s \bigr\rangle$.
\\[0.2cm]
Figure \ref{fig:Compiler.ipynb:compile:not} on page \pageref{fig:Compiler.ipynb:compile:not} shows how the
translation of the negation operator is implemented.

\begin{figure}[!ht]
\centering
\begin{minted}[ frame         = lines, 
                 framesep      = 0.3cm, 
                 firstnumber   = last,
                 bgcolor       = sepia,
                 numbers       = left,
                 numbersep     = -0.2cm,
                 xleftmargin   = 0.8cm,
                 xrightmargin  = 0.8cm,
               ]{python3}
    def compile_expr(expr, st, class_name):
        ...
        elif expr[0] == '!':
            _, arg = expr
            L, sz  = compile_expr(arg, st, class_name)
            CmdLst = ['bipush 1'] + L + ['isub']
            return CmdLst, max(sz1, sz + 1)
        ...
\end{minted}
\vspace*{-0.3cm}
\caption{Translation of the negation operator.}
\label{fig:Compiler.ipynb:compile:not}
\end{figure}


\subsection{Translation of Statements}
Next, we show how statements are compiled.  First of all, we agree that the execution of a statement
must not change the size of the stack:  The size of stack before the execution of a statement must
be the same as the size of the stack after after the statement has been executed.
Of course, during the execution of the statement the stack may well
grow and shrink.  But once the execution of the statement has finished, the stack has to be cleaned from all
intermediate values that have been put on the stack during the execution of the statement.

To compile statements we define a function
\mytt{compile\_stmnt} that has the following signature:
\\[0.2cm]
\hspace*{1.3cm}
$\mytt{compile\_stmnt}: \textsl{Stmnt} \times \textsl{SymbolTable} \times \textsl{ClassName} \rightarrow 
                 \bigl\langle\textsl{List}\mytt{[}\textsl{AsmCmd}\mytt{]}, \mathbb{N}\bigr\rangle.$
\\[0.2cm]
The interpretation of the arguments is similar to the interpretation of the arguments
of the function \mytt{compile\_expr}.  The only difference is that the first argument now is an abstract syntax
tree that represents a statement.

\subsubsection{Translation of Assignments}
To begin with, we show how an assignment of the form 
\[ x \;\mytt{=}\; \textsl{expr} \]
is translated.  The idea is to evaluate \textsl{expr}.  As a consequence of this evaluation  the value of
\textsl{expr} remains on the stack, from where it can be stored in the variable $x$ using the assembler command 
\mytt{istore}. Therefore, if we have
\\[0.2cm]
\hspace*{1.3cm}
$\mytt{compile\_expr}(\textsl{expr}, \mytt{st}, \mytt{class\_name}) = \pair(L, s)$
\\[0.2cm]
we can define:
\\[0.2cm]
\hspace*{1.3cm}
$\mytt{compile\_stmnt}(x = \textsl{expr}, \mytt{st}, \mytt{class\_name})
= \bigl\langle L + \mytt{[istore st[x]]}, s \bigr\rangle $.
\\[0.2cm]
Figure \ref{fig:Compiler.ipynb:compile:assign} on page \pageref{fig:Compiler.ipynb:compile:assign} shows how the
translation of an assignment is implemented.


\begin{figure}[!ht]
\centering
\begin{minted}[ frame         = lines, 
                 framesep      = 0.3cm, 
                 firstnumber   = 1,
                 bgcolor       = sepia,
                 numbers       = left,
                 numbersep     = -0.2cm,
                 xleftmargin   = 0.8cm,
                 xrightmargin  = 0.8cm,
               ]{python3}
    def compile_stmnt(stmnt, st, class_name):
        if stmnt[0] == '=':
            _, var, expr = stmnt
            CmdLst, sz = compile_expr(expr, st, class_name)
            CmdLst    += [f'istore {st[var]}']
            return CmdLst, sz                
        ...
\end{minted}
\vspace*{-0.3cm}
\caption{Translation of an assignment statement.}
\label{fig:Compiler.ipynb:compile:assign}
\end{figure}




\subsubsection{The Translation of Branching Commands}
Next, we show how to translate a branching command of the form
\[ \mytt{if}\; (\textsl{bool\_expr})\; \textsl{stmnt}. \]
Obviously, we first have to translate the Boolean expression \textsl{bool\_expr}.
If we have
\\[0.2cm]
\hspace*{1.3cm}
$\mytt{compile\_expr}(\textsl{bool\_expr}, \mytt{st}, \mytt{class\_name}) = \pair(L_1, s_1)$
\\[0.2cm]
and, furthermore, 
\\[0.2cm]
\hspace*{1.3cm}
$\mytt{compile\_stmnt}(\textsl{stmnt}, \mytt{st}, \mytt{class\_name}) = \pair(L_2, s_2)$,
\\[0.2cm]
then we can define:
\[
   \begin{array}[t]{lcccl}
   \textsl{compile\_stmnt}\bigl(\mytt{if}\; (\textsl{expr})\;\textsl{stmnt}, \mytt{st}, \mytt{class\_name}\bigr) & = & \bigl\langle & & L_1  \\
   &&& + & [\;\mytt{ifeq}\;\textsl{else}\;] \\
   &&& + & L_2 \\
   &&& + & [\;\textsl{else}\mytt{:}\;], \qquad \max(s_1, s_2) \bigr\rangle        
\end{array}
\]
This works because executing the list of assembler commands $L_1$ leaves either a $0$ or a $1$ on the stack.
If \textsl{expr} is false, the top of the stack stores the number $0$.  In this case, the branching command
\mytt{ifeq} branches to the label \textsl{else} and the assembler commands in the list $L_2$ are not
executed.  If \textsl{expr} is true, the top of the stack stores the number $1$.  Therefore, the branching
command \mytt{ifeq} does not branch and the assembler commands in the list $L_2$ are executed,
i.e.~\textsl{stmnt} is executed.

The translation of a branching command of the form
\[ \mytt{if}\; (\textsl{bool\_expr})\; \textsl{stmnt}_1\; \mytt{else}\; \textsl{stmnt}_2 \]
is similar.  Let us assume that we have the following:
\begin{enumerate}
\item $\mytt{compile\_expr}(\textsl{bool\_expr}, \mytt{st}, \mytt{class\_name}) = \pair(L_1, s_1)$
\item $\mytt{compile\_stmnt}(\textsl{stmnt}_1, \mytt{st}, \mytt{class\_name}) = \pair(L_2, s_2)$, and
\item $\mytt{compile\_stmnt}(\textsl{stmnt}_2, \mytt{st}, \mytt{class\_name}) = \pair(L_3, s_3)$.
\end{enumerate}
Then we define:
\\[0.2cm]
\hspace*{0.3cm}
$
   \begin{array}[t]{lcccl}
   \textsl{compile\_stmnt}\bigl(\mytt{if}\; (\textsl{bool\_expr})\;\textsl{stmnt}_1\;\mytt{else}\;\textsl{stmnt}_2, \mytt{st}, \mytt{class\_name}\bigr) & = & \bigl\langle & & L_1  \\
   &&& + & [\;\mytt{ifeq}\;\textsl{else}\;] \\
   &&& + & L_2 \\
   &&& + & [\mytt{goto}\;\textsl{next}] \\
   &&& + & [\;\textsl{else}\mytt{:}\;] \\
   &&& + & L_3 \\
   &&& + & [\;\textsl{next}\mytt{:}\;], \qquad \max(s_1, s_2, s_3) \bigr\rangle        
\end{array}
$
\\[0.2cm]
Figure \ref{fig:Compiler.ipynb:compile:if} on page \pageref{fig:Compiler.ipynb:compile:if} shows how the
translation of branching statements is implemented.

\begin{figure}[!ht]
\centering
\begin{minted}[ frame         = lines, 
                 framesep      = 0.3cm, 
                 firstnumber   = 1,
                 bgcolor       = sepia,
                 numbers       = left,
                 numbersep     = -0.2cm,
                 xleftmargin   = 0.5cm,
                 xrightmargin  = 0.5cm,
               ]{python3}
    def compile_stmnt(stmnt, st, class_name):
        ...
        elif stmnt[0] == 'if':
            _, expr, sub_stmnt = stmnt
            L1, sz1    = compile_bool(expr, st, class_name)
            L2, sz2    = compile_stmnt(sub_stmnt, st, class_name)
            else_label = new_label()
            CmdLst = L1 + [f'ifeq {else_label}'] + L2 + [else_label + ':']
            return CmdLst, max(sz1, sz2)
        elif stmnt[0] == 'if-else':
            _, expr, then_stmnt, else_stmnt = stmnt
            L1, sz1    = compile_bool(expr, st, class_name)
            L2, sz2    = compile_stmnt(then_stmnt, st, class_name)
            L3, sz3    = compile_stmnt(else_stmnt, st, class_name)        
            else_label = new_label()
            next_label = new_label()
            if_stmnt   = f'ifeq {else_label}'
            else_stmnt = else_label + ':'
            next_stmnt = next_label + ':'
            goto_stmnt = f'goto {next_label}'
            CmdLst = L1 + [if_stmnt] + L2 + [goto_stmnt, else_stmnt] + L3 + [next_stmnt]
            return CmdLst, max(sz1, sz2, sz3)
        ...       
\end{minted}
\vspace*{-0.3cm}
\caption{Translation of branching statements.}
\label{fig:Compiler.ipynb:compile:if}
\end{figure}

\subsubsection{Translation of a Loop}
If we want to translate a \mytt{while} loop of the form 
\[ \mytt{while}\;(\textsl{cond})\;\textsl{stmnt} \]
we recursively compute
\\[0.2cm]
\hspace*{1.3cm}
$\mytt{compile\_expr}(\textsl{cond}, \mytt{st}, \mytt{class\_name}) = \pair(L_1, s_1)$
\\[0.2cm]
and
\\[0.2cm]
\hspace*{1.3cm}
$\mytt{compile\_stmnt}(\textsl{stmnt}, \mytt{st}, \mytt{class\_name}) = \pair(L_2, s_2)$,
\\[0.2cm]
Then we can define
\[
   \begin{array}[t]{lcccl}
     \textsl{compile\_stmnt}\bigl(\mytt{while}\; (\textsl{cond})\;\textsl{stmnt}, \mytt{st}, \mytt{class\_name}\bigr)
     & = & \bigl\langle & & [ \textsl{loop}:]  \\
   &&& + & L_1 \\
   &&& + & [\;\mytt{ifeq}\;\textsl{next}\;] \\
   &&& + & L_2 \\
   &&& + & [\mytt{goto}\;\textsl{loop}] \\
   &&& + & [\;\textsl{next}\mytt{:}\;], \qquad \max(s_1, s_2) \bigr\rangle        
\end{array}
\]
Figure \ref{fig:Compiler.ipynb:compile:while} on page \pageref{fig:Compiler.ipynb:compile:while} shows how the
translation of a loop is implemented.

\begin{figure}[!ht]
\centering
\begin{minted}[ frame         = lines, 
                 framesep      = 0.3cm, 
                 firstnumber   = 1,
                 bgcolor       = sepia,
                 numbers       = left,
                 numbersep     = -0.2cm,
                 xleftmargin   = 0.5cm,
                 xrightmargin  = 0.5cm,
               ]{python3}
    def compile_stmnt(stmnt, st, class_name):
        ...
        elif stmnt[0] == 'while':
            _, expr, body_stmnt = stmnt
            L1, sz1    = compile_bool(expr, st, class_name)
            L2, sz2    = compile_stmnt(body_stmnt, st, class_name)
            loop_label = new_label()
            next_label = new_label()
            if_stmnt   = f'ifeq {next_label}'
            loop_stmnt = loop_label + ':'        
            next_stmnt = next_label + ':'
            goto_stmnt = f'goto {loop_label}'
            CmdLst = [loop_stmnt] + L1 + [if_stmnt] + L2 + [goto_stmnt, next_stmnt]
            return CmdLst, max(sz1, sz2)
        ...       
\end{minted}
\vspace*{-0.3cm}
\caption{Translation of a loop.}
\label{fig:Compiler.ipynb:compile:while}
\end{figure}

\subsubsection{Translation of a Return Statement}
In order to translate a return statement of the form
\\[0.2cm]
\hspace*{1.3cm}
$\mytt{return}\; \textsl{expr} \mytt{;}$
\\[0.2cm]
we first have to translate the expression \textsl{expr}.  Assume that
\\[0.2cm]
\hspace*{1.3cm}
$\mytt{compile\_expr}(\textsl{expr}, \mytt{st}, \mytt{class\_name}) = \pair(L, s)$.
\\[0.2cm]
Then we can define
\\[0.2cm]\hspace*{1.3cm}
$\mytt{compile\_stmnt}(\mytt{return}\; \textsl{expr} \mytt{;}, \mytt{st}, \mytt{class\_name}) =
 \bigl\langle L + [\mytt{ireturn}], s \bigr\rangle$.
\\[0.2cm]
Figure \ref{fig:Compiler.ipynb:compile:return} on page \pageref{fig:Compiler.ipynb:compile:return} shows how a
return statement is translated.

\begin{figure}[!ht]
\centering
\begin{minted}[ frame         = lines, 
                 framesep      = 0.3cm, 
                 firstnumber   = 1,
                 bgcolor       = sepia,
                 numbers       = left,
                 numbersep     = -0.2cm,
                 xleftmargin   = 0.5cm,
                 xrightmargin  = 0.5cm,
               ]{python3}
    def compile_stmnt(stmnt, st, class_name):
        ...
        elif stmnt[0] == 'return':
            _, expr = stmnt
            CmdLst, sz = compile_expr(expr, st, class_name)
            CmdLst    += ['ireturn']
            return CmdLst, sz
        ...       
\end{minted}
\vspace*{-0.3cm}
\caption{Translation of a return statement.}
\label{fig:Compiler.ipynb:compile:return}
\end{figure}

\subsubsection{Translating a Block Statement}
The translation of block statement of the form
\[ \{ \textsl{stmnt}_1\mytt{;}\; \cdots\; \textsl{stmnt}_n\mytt{;} \} \]
proceeds by translating the statements $\textsl{stmnt}_i$ separately.  Assume that
\\[0.2cm]
\hspace*{1.3cm}
$\mytt{compile\_stmnt}(\textsl{stmnt}_i, \mytt{st}, \mytt{class\_name}) = \pair(L_i, s_i)$
\quad for $i=1,\cdots,n$.
\\[0.2cm]
Then we define
\[
     \textsl{compile\_stmnt}\bigl(\mytt{\{} \textsl{stmnt}_1\mytt{;}\; \cdots\; \textsl{stmnt}_n\mytt{;} \mytt{\}},
     \mytt{st}, \mytt{class\_name}\bigr) :=
     \bigl\langle L_1 + \cdots + L_n, \max(s_1, \cdots, s_n) \bigr\rangle.
\]
Figure \ref{fig:Compiler.ipynb:compile:block} on page \pageref{fig:Compiler.ipynb:compile:block} shows how the
translation of a block statement is implemented.

\begin{figure}[!ht]
\centering
\begin{minted}[ frame         = lines, 
                 framesep      = 0.3cm, 
                 firstnumber   = 1,
                 bgcolor       = sepia,
                 numbers       = left,
                 numbersep     = -0.2cm,
                 xleftmargin   = 0.8cm,
                 xrightmargin  = 0.8cm,
               ]{python3}
    def compile_stmnt(stmnt, st, class_name):
        ...
        elif stmnt[0] == '.':
            _, *stmnt_lst = stmnt 
            CmdLst = []
            size   = 0
            for s in stmnt_lst:
                L, sz = compile_stmnt(s, st, class_name)
                CmdLst += L
                size   = max(size, sz)
            return CmdLst, size
\end{minted}
\vspace*{-0.3cm}
\caption{Translation of an expression statement.}
\label{fig:Compiler.ipynb:compile:block}
\end{figure}


\subsubsection{Translation of Expression Statements}
When we translate an expression statement of the form
\\[0.2cm]
\hspace*{1.3cm}
\textsl{expr} \mytt{;}
\\[0.2cm]
we assume that the evaluation of the expression does not leave a value on the stack.
At present, the only expression whose evaluation does not create a value is an invocation of the function
\mytt{println}.  Then in order to evaluate the expression statement, we just have to evaluate the expression.
Therefore, we have
\\[0.2cm]
\hspace*{1.3cm}
$\mytt{compile\_stmnt}(\textsl{expr}\mytt{;}, \mytt{st}, \mytt{class\_name})
=  \mytt{compile\_expr}(\textsl{expr}, \mytt{st}, \mytt{class\_name})$.
\\[0.2cm]
Figure \ref{fig:Compiler.ipynb:compile:expr_stmnt} on page \pageref{fig:Compiler.ipynb:compile:expr_stmnt} shows how the
translation of an expression statement is implemented.

\begin{figure}[!ht]
\centering
\begin{minted}[ frame         = lines, 
                 framesep      = 0.3cm, 
                 firstnumber   = 1,
                 bgcolor       = sepia,
                 numbers       = left,
                 numbersep     = -0.2cm,
                 xleftmargin   = 0.8cm,
                 xrightmargin  = 0.8cm,
               ]{python3}
    def compile_stmnt(stmnt, st, class_name):
        ...
       else: # it must be an expression statement
            CmdLst, sz = compile_expr(stmnt, st, class_name)
            return CmdLst, sz
\end{minted}
\vspace*{-0.3cm}
\caption{Translation of an expression statement.}
\label{fig:Compiler.ipynb:compile:expr_stmnt}
\end{figure}


\subsection{Translation of a Function Definition}
\begin{figure}[!ht]
\centering
\begin{minted}[ frame         = lines, 
                 framesep      = 0.3cm, 
                 firstnumber   = 1,
                 bgcolor       = sepia,
                 numbers       = left,
                 numbersep     = -0.2cm,
                 xleftmargin   = 0.8cm,
                 xrightmargin  = 0.8cm,
               ]{python3}
    def compile_fct(fct_def, class_name):
        global label_counter
        label_counter = 0
        _, name, parameters, variables, stmnts = fct_def
        _, *parameters = parameters
        _, *variables  = variables
        _, *stmnts     = stmnts
        m   = len(parameters)
        n   = len(variables)
        st  = {}
        cnt = 0
        for var in parameters:
            st[var] = cnt
            cnt    += 1
        for var in variables:
            st[var] = cnt
            cnt    += 1
        CmdLst = []
        size   = 0
        for stmnt in stmnts:
            L, sz = compile_stmnt(stmnt, st, class_name)
            CmdLst += L
            size = max(size, sz)
        limit_locals = f'.limit locals {m+n}'
        limit_stack  = f'.limit stack  {size}'
        if name != 'main':
            method = f'.method public static {name}({"I"*m})I'
            CmdLst = [method, limit_locals, limit_stack] + CmdLst + ['.end method']
            return CmdLst, sz
        else:
            method = '.method public static main([Ljava/lang/String;)V'
            CmdLst = [method, limit_locals, limit_stack] + CmdLst + \
                     ['return', '.end method']
            return CmdLst, sz
\end{minted}
\vspace*{-0.3cm}
\caption{Translation of a function definition.}
\label{fig:Compiler.ipynb:compile:fct}
\end{figure}
\noindent
Figure \ref{fig:Compiler.ipynb:compile:fct} on page \pageref{fig:Compiler.ipynb:compile:fct} shows how a
function definition is translated.  
In order to understand how this works we have to understand what type of code the function \mytt{compile} has
to generate.  Depending on whether the function that is translated is the function \mytt{main} or not there
are two cases.
\begin{enumerate}
\item If the function that  is to be compiled has the name \squoted{main}, the code that has to be generated
      has the following form:

      \begin{Verbatim}[ frame         = lines, 
                        framesep      = 0.3cm, 
                        labelposition = bottomline,
                        numbers       = left,
                        numbersep     = -0.2cm,
                        xleftmargin   = 0.8cm,
                        xrightmargin  = 0.8cm,
                        commandchars  = \\\{\},
                        codes={\catcode`$=3\catcode`^=7\catcode`_=8}
                      ]
            .method public static main([Ljava/lang/String;)V
            .limit locals \(l\) 
            .limit stack \(s\)
               \(s_1\)
               \(\vdots\)
               \(s_n\)
               return
            .end method
       \end{Verbatim}
       % \$

       Here $l$ is the number of all variables used by the function \mytt{main}, while $s$ is the maximum
       height of the stack.
       Finally,  $s_1$, $\cdots$, $s_n$ are the assembler commands that result from translating the block
       inside the function.
\pagebreak
       
\item Otherwise, the following code is to be generated:

      \begin{Verbatim}[ frame         = lines, 
                        framesep      = 0.3cm, 
                        labelposition = bottomline,
                        numbers       = left,
                        numbersep     = -0.2cm,
                        xleftmargin   = 0.8cm,
                        xrightmargin  = 0.8cm,
                        commandchars  = \\\{\},
                        codes={\catcode`$=3\catcode`^=7\catcode`_=8}
                      ]
            .method public static \(f\)(I\(\cdots\)I)I
            .limit locals \(l\) 
            .limit stack \(s\)
               \(s_1\)
               \(\vdots\)
               \(s_n\)
            .end method
       \end{Verbatim}
       % $
       
       Here $f$ is the name of the function.  The signature of $f$ is a string of the form
       \\[0.2cm]
       \hspace*{1.3cm}
       $f(\underbrace{\mytt{I}\cdots\mytt{I}}_{m})\mytt{I}$
       \\[0.2cm]
       where $m$ is the number of the parameters.  Furthermore, 
       $l$ is the number of all local variables and  $s$
       is the maximum height of the stack.  Finally,
       $s_1$, $\cdots$, $s_n$ are the assembler commands that result from translating the block inside the function.
\end{enumerate}
We proceed to discuss the implementation shown in Figure \ref{fig:Compiler.ipynb:compile:fct} line by line.
\begin{enumerate}
\item We initialize the global variable \mytt{label\_counter} to $0$.
      Every time a new label is generated, this counter will be incremented by the function \mytt{new\_label}
      that creates labels of the form \mytt{l1}, \mytt{l2}, etc.
\item The nested tuple that is produced by the parser from a function definition has the form
      \\[0.2cm]
      \hspace*{1.3cm}
      $(\mytt{'fct'}, \textsl{name}, \textsl{parameters}, \textsl{variables}, \textsl{stmnts})$.
      \begin{enumerate}[(a)]
      \item \textsl{name} is the name of the function.
      \item \textsl{parameters} is the abstract syntax tree representing the list of parameters.
      \item \textsl{variables} is the abstract syntax tree representing the list of all local variables
            declared in the function. 
      \item \textsl{stmnts} is the the abstract syntax tree representing the list of all statements in the body
            of the function. 
      \end{enumerate}
\item Initially, the parameters, variables, and statements are stored as nested tuples.
      In line 5-7 these nested tuples are transformed into proper lists.
\item $m$ is the number of parameters. 
\item $n$ is the number of local variables. 
\item The \mytt{for} loops in line 12--17 initialize the symbol table \mytt{st}.
      Given a parameter or local variable $x$, the expression \mytt{st[$x$]}
      returns the position in the local variable frame where the parameter or variable is stored.
\item The \mytt{for} loop in line 20--23 translates the statements in the body of the function one by one.
  Furthermore, it computes the size of the stack that is needed.
\item Line 24 declares the size of the local variable frame.  The pseudo-command \mytt{.limit locals}
  reserves memory for the parameters and the local variables.
\item Line 25 declares the size of the stack needed by the function.
\item Depending on whether the function that is compiled is the function \mytt{main} or not,
  the correct code is returned.
\end{enumerate}

\subsection{Compiling a Program}
We conclude this chapter by presenting the function \mytt{compile\_program} that is shown in Figure
\ref{fig:Compiler.ipynb:compile_program} on page \pageref{fig:Compiler.ipynb:compile_program}. This function
takes the name of a file as its argument.  This file is expected to contain a program written in the subset
of the programming language \mytt{C} that has been presented in this chapter.  If the name of this file is, for example,
\mytt{Test.c}, then the function \mytt{compile\_program} generates a file with the name \mytt{Test.jas},
that contains an assembler program that adheres to the rules of \textsl{Jasmin}. We proceed to discuss the
function \mytt{compile\_program} line by line. 

\begin{figure}[!ht]
\centering
\begin{minted}[ frame         = lines, 
                 framesep      = 0.3cm, 
                 firstnumber   = 1,
                 bgcolor       = sepia,
                 numbers       = left,
                 numbersep     = -0.2cm,
                 xleftmargin   = 0.8cm,
                 xrightmargin  = 0.8cm,
                 ]{python3}
    import os
                 
    def compile_program(file_name):
        directory = os.path.dirname(file_name)
        base      = os.path.basename(file_name)
        base      = base[:-2]
        with open(file_name, 'r') as handle:
            program = handle.read() 
        ast = yacc.parse(program)
        _, *fct_lst = ast
        CmdLst      = []
        for fct in fct_lst:
            L, _ = compile_fct(fct, base)
            CmdLst += L + ['\n']
        with open(directory + '/' + base + '.jas', 'w') as handle:
            handle.write('.class public ' + base + '\n');
            handle.write('.super java/lang/Object\n\n');
            handle.write('.method public <init>()V\n');
            handle.write('    aload 0\n');
            handle.write('    invokenonvirtual java/lang/Object/<init>()V\n');
            handle.write('    return\n');
            handle.write('.end method\n\n');
            for cmd in CmdLst:
                handle.write(cmd + '\n')                
\end{minted}
\vspace*{-0.3cm}
\caption{Translation of a program.}
\label{fig:Compiler.ipynb:compile_program}
\end{figure}

\begin{enumerate}
\item In line 1 we import the module \mytt{os}.  This module contains the submodule \mytt{path} which
      contains the functions \mytt{dirname}  and \mytt{basename}.
      \begin{enumerate}[(a)]
      \item The function \mytt{dirname} takes a string specifying a \textsl{file path}, e.g.~something like
            \\[0.2cm]
            \hspace*{1.3cm}
            \mytt{'\symbol{126}/Dropbox/Formal-Languages/Ply/Examples/Test.c'} 
            \\[0.2cm]
            and returns the name of the directory.  In the example given above it would return the string
            \\[0.2cm]
            \hspace*{1.3cm}
            \mytt{'\symbol{126}/Dropbox/Formal-Languages/Ply/Examples'}. 
      \item The function \mytt{basename} takes a \textsl{file path}
            and returns the name of the filename of the directory.  In the example given previously
            it would return the string \mytt{'Test.c'}.
      \end{enumerate}
      The module \mytt{os} is aware of the differences in naming directories that exist in different operating
      systems.     
\item After computing the \mytt{directory} of the file and its \mytt{base} in line 4 and 5, we remove the 
      file extension \mytt{'.c'} in line 6.
\item Line 7 and 8 read the file and store its content into the string \mytt{program}.
\item In line 9 our parser converts the program into an abstract syntax tree that is represented as a nested
      tuple.  
\item \mytt{fct\_lst} is a list of all function definitions occurring in the given program.
\item \mytt{CmdLst} is a list of all assembler commands that will be generated. 
\item The \mytt{for} loop in line 12--14 translates all function definitions into assembler code
      and concatenates the assembler statements into the list \mytt{CmdLst}.
\item In line 15 the output file is opened for writing.
\item Line 16--22 write the initialization code to the output file.
\item The \mytt{for} loop in line 23--24 writes the generated assembler commands to the output file.
\end{enumerate}
Figure \ref{fig:MySum.c2} on page \pageref{fig:MySum.c2} shows an integer \mytt{C} program for computing the
sum $\sum\limits_{i=1}^{6^2}i$.  When we translate this program using the compiler developed in this chapter,
we get the program that is shown in Figure \ref{fig:MySum.jas} on page \pageref{fig:MySum.jas}.

\begin{figure}[!ht]
\centering
\begin{minted}[ frame         = lines, 
                 framesep      = 0.3cm, 
                 firstnumber   = 1,
                 bgcolor       = sepia,
                 numbers       = left,
                 numbersep     = -0.2cm,
                 xleftmargin   = 0.8cm,
                 xrightmargin  = 0.8cm,
                 ]{c}
    int sum(int n) {
        int s;
        s = 0;
        while (n != 0) {
            s = s + n;
            n = n - 1;
        }
        return s;
    }
    
    int main() {
        int n;
        n = 6 * 6;
        println(sum(n));
    }
\end{minted}
\vspace*{-0.3cm}
\caption{A \mytt{C} program for computing the sum $\sum\limits_{i=1}^{6^2}i$.}
\label{fig:MySum.c2}
\end{figure}

\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                 framesep      = 0.3cm, 
                 firstnumber   = 1,
                 numbers       = left,
                 numbersep     = -0.2cm,
                 xleftmargin   = 0.8cm,
                 xrightmargin  = 0.8cm,
               ]
    .class public MySum
    .super java/lang/Object
    
    .method public <init>()V
        aload 0
        invokenonvirtual java/lang/Object/<init>()V
        return
    .end method
        
    .method public static sum(I)I
    .limit locals 2
    .limit stack  2
            ldc 0
            istore 1
        l3: iload 0
            ldc 0
            if_icmpne l1
            bipush 0
            goto l2
        l1: bipush 1
        l2: ifeq l4
            iload 1
            iload 0
            iadd
            istore 1
            iload 0
            ldc 1
            isub
            istore 0
            goto l3
        l4: iload 1
            ireturn
    .end method
            
    .method public static main([Ljava/lang/String;)V
    .limit locals 1
    .limit stack  2
            ldc 6
            ldc 6
            imul
            istore 0
            getstatic java/lang/System/out Ljava/io/PrintStream;
            iload 0
            invokestatic MySum/sum(I)I
            invokevirtual java/io/PrintStream/println(I)V
            return
    .end method
\end{Verbatim}
\vspace*{-0.3cm}
\caption{Assembler program generated by our compiler.}
\label{fig:MySum.jas}
\end{figure}

\vspace*{\fill}
\pagebreak
\vspace*{\fill}
\pagebreak
\vspace*{\fill}
\pagebreak

\exerciseEng
Extend the compiler that is presented in this chapter and is available at
\\[0.2cm]
\hspace*{1.3cm}
\href{https://github.com/karlstroetmann/Formal-Languages/blob/master/Ply/Compiler.ipynb}{\texttt{https://github.com/karlstroetmann/Formal-Languages/blob/master/Ply/Compiler.ipynb}}
\\[0.2cm]
so that a new kind of \mytt{for}-loops is supported.
Figure \ref{fig:MySum.c3} on page \pageref{fig:MySum.c3} shows an example of the use of this kind of
\mytt{for} loop. 
\eox

\begin{figure}[!ht]
\centering
\begin{minted}[ frame         = lines, 
                 framesep      = 0.3cm, 
                 firstnumber   = 1,
                 bgcolor       = sepia,
                 numbers       = left,
                 numbersep     = -0.2cm,
                 xleftmargin   = 0.8cm,
                 xrightmargin  = 0.8cm,
                 ]{c}
    int sum(int n) {
        int s;
        int i;
        s = 0;
        for (i = 1 .. n) {
            s = s + i;
        }
        return s;
    }
\end{minted}
\vspace*{-0.3cm}
\caption{A function for computing the sum $\sum\limits_{i=1}^{n}i$.}
\label{fig:MySum.c3}
\end{figure}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "formal-languages"
%%% End: 

\section{Code Generation}
Next, we discuss the generation of code.  We structure our representation by discussing the code generation for
arithmetic expressions, Boolean expression, statements, and function definitions separately. 

\subsection{Translation of Arithmetic Expressions}
Given an arithmetic expression $e$, the translation of $e$ is supposed to generate some code that, when
executed, places the result of evaluating the expression $e$ onto the stack.  To this end we define a function
\texttt{compile} that has the following signature:
\\[0.2cm]
\hspace*{1.3cm}
$\mytt{compile}: \textsl{Expr} \times \textsl{SymbolTable} \times \textsl{ClassName} \rightarrow 
                 \textsl{Pair}\mathtt{<}\textsl{List}\mathtt{<}\textsl{AsmCmd}\mathtt{>}, \mathbb{N}\mathtt{>}.$
\\[0.2cm]
A call to this function has the form
\\[0.2cm]
\hspace*{1.3cm}
$\mytt{compile}(\mytt{expr}, \mytt{st}, \mytt{name})$.
\\[0.2cm]
The interpretation of the arguments is as follows:
\begin{enumerate}[(a)]
\item \texttt{expr} is the arithmetic expression that is to be translated into assembler code.
\item \texttt{st} is the \blue{symbol table}: \index{symbol table} Concretely, this is a dictionary that maps
      the variable names to their position on the stack.  For example, if \squoted{x} is a variable that is the
      third variable in the local variable frame, then we have
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{st['x'] = 2},
      \\[0.2cm]
      because the first variable in the local variable frame has index 0.  We will discuss later how the 
      positions of the variables on the stack is fixed.
\item \texttt{name} is the name of the class that is to be used by our compiler.

     As we generate \textsl{Java} assembler and in \textsl{Java} every function has to be a part of a class,
     all functions that we create have to be static functions that are defined inside a class.  Therefore,
     \texttt{name} is the name of this class.

     This argument \texttt{name} is only needed when function calls are translated.
\end{enumerate}
The function \texttt{compile} returns a pair.  
\begin{enumerate}[(a)]
\item The first component of this pair is a list of \textsl{Java} 
      assembler commands that adhere to the syntax recognized by \textsl{Jasmin}.  In general, when the
      expression that is translated is complex, the execution of these assembler commands might need
      considerable room on the stack.  However, it has to be guaranteed that when the execution of theses
      commands finishes, the stack is back to its original height plus one because the net 
      effect of executing these commands must be to put the value of the expression on the stack.
\item The second component of the return value of \texttt{compile} is a natural number.
      This natural number tells us how much the stack might grow when \texttt{expr} is evaluated.
      This information is needed because the \textsl{Java} virtual machine needs this information in advance:
      In \textsl{Java}, every function has to declare how much space it might use on the stack.
      This declaration is done using the pseudo assembler command \texttt{.limit}.  Controlling the 
      maximum height of the stack is a security feature of \textsl{Java} that prevents those exploits that
      utilize stack overflows.
\end{enumerate}
In the following, we discuss the evaluation of the different arithmetic expressions one by one.


\subsubsection{Übersetzung einer Variablen}
Um eine Variable $v$ auszuwerten, laden wir diese Variable mit dem Kommando 
\[  \texttt{iload}\;\; v  \]
auf den Stack.  Daher hat die Klasse \texttt{Variable} die in Abbildung \ref{fig:Expr:Variable.java}
gezeigte Form.  Die Klasse Variable verwaltet eine Member-Variable mit dem Namen
\texttt{mName}, die den Namen der Variablen angibt.  Die Methode $\textsl{compile}()$ legt
zunächst in Zeile 8 eine neue Liste von Assembler-Kommandos an und erzeugt dann in Zeile
9 das Assembler-Kommando
\[ \texttt{iload}\;\;v, \]
das als einziges Kommando in diese Liste eingefügt wird.  Hierbei ist $v$ die Nummer der Variablen,
die in der Symbol-Tabelle, die dem Konstruktor als Argument übergeben wird, gespeichert ist.
Anschließend kann die Liste als Ergebnis zurück gegeben werden.

Die Methode \texttt{stackSize} gibt beim Laden einer Variablen  den Wert $1$ zurück, denn es
wird ja nur ein Objekt auf dem Stack abgelegt.

\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.8cm,
                  xrightmargin  = 0.8cm,
                ]
    public class Variable extends Expr {
        private String mName;
    
        public Variable(String name) {
            mName = name;
        }
        public List<AssemblerCmd> compile(Map<String, Integer> symbolTable) {
            List<AssemblerCmd> result = new LinkedList<AssemblerCmd>();
            AssemblerCmd iload = new ILOAD(symbolTable.get(mName));
            result.add(iload);
            return result;
        }
        public Integer stackSize() {
            return 1;
        }
    }
\end{Verbatim}
\vspace*{-0.3cm}
\caption{Die Klasse \texttt{Variable}.}
\label{fig:Expr:Variable.java}
\end{figure}

\subsubsection{Übersetzung einer Konstanten}
Eine Konstante $c$ kann mit Hilfe des Befehls
\\[0.2cm]
\hspace*{1.3cm}
\texttt{ldc} $c$
\\[0.2cm]
auf den Stack geladen werden.


\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.8cm,
                  xrightmargin  = 0.8cm,
                ]
    public class MyNumber extends Expr {
        private Integer mNumber;
    
        public MyNumber(Integer number) {
            mNumber = number;
        }
        public List<AssemblerCmd> compile(Map<String, Integer> symbolTable) {
            List<AssemblerCmd> result = new LinkedList<AssemblerCmd>();
            AssemblerCmd ldc = new LDC(mNumber);
            result.add(ldc);
            return result;
        }
        public Integer stackSize() {
            return 1;
        }    
    }
\end{Verbatim}
\vspace*{-0.3cm}
\caption{Die Klasse \texttt{MyNumber}.}
\label{fig:Expr:MyNumber.java}
\end{figure}

Abbildung \ref{fig:Expr:MyNumber.java} zeigt die Implementierung der Klasse
\texttt{MyNumber}, die eine Konstante darstellt.  Die Konstante selbst wird in der 
Member-Variablen \texttt{mNumber} gespeichert.  
Die Methode $\textsl{compile}()$ gibt eine 
Liste zurück, die den Befehl \texttt{ldc} enthält.

Die Methode \texttt{stackSize} gibt  den Wert $1$ zurück, den es wird ja nur eine Zahl auf den
Stack gelegt.

\subsubsection{Übersetzung zusammengesetzter Ausdrücke}
Um einen Ausdruck der Form
\[ \textsl{lhs} \quoted{+} \textsl{rhs} \]
zu übersetzen, muss zunächst Code erzeugt werden, der die Ausdrücke \textsl{lhs} und
\textsl{rhs} rekursiv übersetzt.  Wird dieser Code ausgeführt, so liegen  auf dem Stack
anschließend die Werte von \textsl{lhs} und \textsl{rhs}.  Durch den Befehl \texttt{iadd} werden diese
nun addiert.  Die Übersetzung kann also wie folgt spezifiziert werden:
\[ \textsl{compile}(\textsl{lhs} \quoted{+} \textsl{rhs}) = 
   \textsl{lhs}.\textsl{compile}() + \textsl{rhs}.\textsl{compile}() + [ \texttt{iadd} ],  
\]
wobei der Operator ``+'' auf der rechten Seite dieser Gleichung der Verkettung von Listen dient.  Abbildung
\ref{fig:Expr:Sum.java} zeigt die Umsetzung dieser Überlegung.  

Bei der Berechnung der Größe des benötigten Stacks gehen wir von folgenden Überlegungen aus:
\begin{enumerate}
\item Zunächst benötigen wir für die Auswertung von \textsl{lhs} einen Stack der Größe
      $\textsl{lhs}.\mathtt{stackSize}()$.  Nachdem \textsl{lhs ausgewertet}  worden ist, verbleibt
      aber nur der Wert von \textsl{lhs} auf dem Stack.
\item Falls wir für die Auswertung von \textsl{rhs} weniger Platz auf dem Stack benötigen als für
      die Auswertung von \textsl{lhs}, dann reicht insgesamt der Stack aus, der für die Auswertung
      von \textsl{lhs} allokiert worden ist, denn das Ergebnis der Auswertung von \textsl{lhs}
      benötigt nur eine Speicherstelle und da die Auswertung von \textsl{rhs} nach Voraussetzung
      weniger Platz auf dem Stack benötigt als die Auswertung von \textsl{lhs} benötigt hat, reicht
      der verbleibende Platz auf dem Stack aus um \textsl{rhs} auszuwerten.
\item Falls die Auswertung von \textsl{rhs} genauso viel oder mehr Platz braucht als die Auswertung von \textsl{lhs},
      dann muss der Stack insgesamt die Höhe
      \\[0.2cm]
      \hspace*{1.3cm}
      $\textsl{rhs}.\texttt{stackSize}() + 1$
      \\[0.2cm]
      haben, denn wir müssen zusätzlich ja noch das Ergebnis der Auswertung von \textsl{lhs} speichern.
\end{enumerate}
Insgesamt sehen wir, dass die Höhe des Stacks durch die Formel
\\[0.2cm]
\hspace*{1.3cm}
$\texttt{max}(\textsl{lhs}.\texttt{stackSize}(), \textsl{rhs}.\texttt{stackSize}() + 1)$
\\[0.2cm]
gegeben ist.
Die Übersetzung von Ausdrücken der Form 
\[ \textsl{lhs} - \textsl{rhs}, \quad\textsl{lhs} * \textsl{rhs} 
   \quad \mbox{und} \quad\textsl{lhs} / \textsl{rhs} 
\]
verläuft nach demselben Schema.  Statt des Befehls \texttt{iadd} verwenden wir hier die
entsprechenden Befehle \texttt{isub}, \texttt{imul} und \texttt{idiv}.



\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.3cm,
                  xrightmargin  = 0.3cm,
                ]
    public class Sum extends Expr {
        private Expr mLhs;
        private Expr mRhs;
    
        public Sum(Expr lhs, Expr rhs) {
            mLhs = lhs;
            mRhs = rhs;
        }
        public List<AssemblerCmd> compile(Map<String, Integer> symbolTable) {
            List<AssemblerCmd> result = mLhs.compile(symbolTable);
            result.addAll(mRhs.compile(symbolTable));
            result.add(new IADD());
            return result;
        }
        public Integer stackSize() {
            return Math.max(mLhs.stackSize(), mRhs.stackSize() + 1);
        }
    }
\end{Verbatim}
\vspace*{-0.3cm}
\caption{Die Klasse \texttt{Sum}.}
\label{fig:Expr:Sum.java}
\end{figure}



\subsubsection{Übersetzung von Funktions-Aufrufen}
Ein Funktions-Aufruf der Form $f(e_1, \cdots, e_n)$ kann übersetzt werden, indem zunächst die
Ausdrücke $e_1$, $\cdots$, $e_n$ übersetzt werden.  Anschließend wird dann die Funktion
$f$ mit Hilfe des Kommandos \texttt{invokevirtual} aufgerufen.  
 Damit hat die Übersetzung im Allgemeinen die folgende Form:
\\[0.2cm]
$ \textsl{compile}\bigl(f(e_1,\cdots,e_n)\bigr) = 
   \textsl{compile}(e_1) + \cdots + \textsl{compile}(e_n) + [ \texttt{invokevirtual}\; f] 
$
\\[0.2cm]
Allerdings müssen wir noch einen Sonderfall berücksichtigen. Falls es sich bei der Funktion $f$
um die Funktion \texttt{println}() handelt, so müssen wir vor der eigentlichen Ausgabe
noch den \texttt{PrintStream} auf den Stack legen, anschließend ist das Argument auszuwerten und zum
Schluss können wir dann die Methode \texttt{println} aufrufen.  Da die Funktion \texttt{println}
selber kein Ergebnis berechnet, ist es in diesem Fall erforderlich, einen Dummy-Wert auf dem Stack abzulegen.
Philosophische Betrachtungen, die über den Rahmen der Vorlesung hinausgehen, legen nahe, hierfür den
Wert 42 zu wählen. 


\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.3cm,
                  xrightmargin  = 0.3cm,
                ]
    public class FunctionCall extends Expr {
        private String     mName;
        private List<Expr> mArgs;
    
        public FunctionCall(String name, List<Expr> args) {
            mName = name;
            mArgs = args;
        }
        public List<AssemblerCmd> compile(Map<String, Integer> symbolTable) {
            List<AssemblerCmd> result = new LinkedList<AssemblerCmd>();
            if (mName.equals("println")) { 
                AssemblerCmd getStatic = 
                    new GETSTATIC("java/lang/System/out Ljava/io/PrintStream;");
                result.add(getStatic);
                for (Expr arg: mArgs) {
                    result.addAll(arg.compile(symbolTable));
                }
                AssemblerCmd println = new PRINTLN();
                AssemblerCmd bipush  = new BIPUSH(42);
                result.add(println);
                result.add(bipush);
                return result;
            }
            for (Expr arg: mArgs) {
                result.addAll(arg.compile(symbolTable));
            }
            String descr = Compiler.sClassName + "/" + mName + "(";
            for (int i = 0; i < mArgs.size(); ++i) {
                descr += "I";
            }
            descr += ")I";
            AssemblerCmd invoke = new INVOKE(descr);
            result.add(invoke);
            return result;
        }
        public Integer stackSize() {
            Integer biggest = 0;
            for (int i = 0; i < mArgs.size(); ++i) {
                biggest = Math.max(biggest, i + mArgs.get(i).stackSize());
            }
            if (mName.equals("println")) {
                ++biggest;
            }
            return Math.max(biggest, 1);
        }
    }
\end{Verbatim}
\vspace*{-0.3cm}
\caption{Die Klasse \texttt{FunctionCall}.}
\label{fig:Expr:FunctionCall.java}
\end{figure}

Abbildung \ref{fig:Expr:FunctionCall.java} zeigt die Implementierung der Klasse
\texttt{FunctionCall}, die einen Funktions-Aufruf repräsentiert.  Die Klasse hat zwei
Member-Variablen.
\begin{enumerate}
\item \texttt{mName} ist der Name der aufgerufenen Funktion.
\item \texttt{mArgs} ist die Liste der Argumente, mit der die Funktion aufgerufen wird.
\end{enumerate}
Falls es sich bei der Funktion nicht um die Methode \texttt{println} handelt, werden zunächst alle
Argumente der Funktion ausgewertet und die Ergebnisse dieser Argumente auf dem Stack abgelegt.
Schließlich wird die Funktion über den Befehl \texttt{invokevirtual} aufgerufen, der durch die
Klasse \texttt{INVOKE} dargestellt wird.

Bei der Berechnung der Größe des benötigten Stacks ist zu berücksichtigen, das bei der Auswertung
des Arguments mit dem Index $i$ bereits $i$ Werte auf dem Stack liegen.
\pagebreak


\subsection{Übersetzung von Boole'schen Ausdrücken}
Boole'sche Ausdrücke werden aus Gleichungen und Ungleichungen mit Hilfe der logischen Operatoren
\qote{!} (Negation), \qote{\&\&} (Konjunktion) und \qote{||} (Disjunktion) aufgebaut.
Wir beginnen mit der Übersetzung von Gleichungen.

\subsubsection{Übersetzung von Gleichungen}
Bevor wir eine Gleichung der Form
\[ \textsl{lhs}\; \texttt{==} \;\textsl{rhs} \]
übersetzen können, müssen wir uns überlegen, was der erzeugte Code überhaupt erreichen soll.  Eine
naheliegende Forderung ist, dass am Ende auf dem Stack eine 1 abgelegt wird, wenn die Werte der
beiden Ausdrücke \textsl{lhs} und \textsl{rhs} übereinstimmen.  Andernfalls soll auf dem Stack eine
0 abgelegt werden.  Die Übersetzung kann unter diesen Annahmen wie folgt ablaufen:


\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.8cm,
                  xrightmargin  = 0.8cm,
                ]
    public class Equation extends BoolExpr {
        private Expr mLhs;
        private Expr mRhs;
    
        public Equation(Expr lhs, Expr rhs) {
            mLhs = lhs;
            mRhs = rhs;
        }
        public List<AssemblerCmd> compile(Map<String, Integer> symbolTable) {
            List<AssemblerCmd> result = mLhs.compile(symbolTable);
            result.addAll(mRhs.compile(symbolTable));
            LABEL        trueLabel = new LABEL();
            LABEL        nextLabel = new LABEL();
            AssemblerCmd if_icmpeq = new IF_ICMPEQ(trueLabel.getLabel());
            AssemblerCmd bipush0   = new BIPUSH(0);
            AssemblerCmd gotoNext  = new GOTO(nextLabel.getLabel());
            AssemblerCmd bipush1   = new BIPUSH(1);
            result.add(if_icmpeq);
            result.add(bipush0);
            result.add(gotoNext);
            result.add(trueLabel);
            result.add(bipush1);
            result.add(nextLabel);
            return result;
        }
        public Integer stackSize() {
            return Math.max(mLhs.stackSize(), mRhs.stackSize() + 1);
        }
    }
\end{Verbatim}
\vspace*{-0.3cm}
\caption{Die Klasse \texttt{Equation}.}
\label{fig:Expr:Equation.java}
\end{figure}

\begin{enumerate}
\item Zunächst erzeugen wir in den Zeilen 10 und 11 den Code zur Auswertung von \textsl{lhs} und \textsl{rhs}.
      Wenn dieser Code abgearbeitet worden ist, liegen die Werte von \textsl{lhs} und \textsl{rhs}
      auf dem Stack.
\item Anschließend überprüfen wir mit Hilfe des Befehls \texttt{if\_icmpeq}, ob die beiden Werte
      gleich sind.  Falls dies so ist, legen wir eine 1 auf den Stack, sonst eine 0.
\end{enumerate}
Damit hat der erzeugte Code insgesamt die folgende Form
\[
   \begin{array}[t]{lcl}
   \textsl{compile}(\textsl{lhs}\;\texttt{==}\;\textsl{rhs}) & = & 
         \textsl{lhs}.\textsl{compile}()  \\
   & + & \textsl{rhs}.\textsl{compile}()  \\
   & + & [ \;\texttt{if\_icmpeq}\; \textsl{true} \; ]  \\
   & + & [ \;\texttt{bipush}\;0\; ]  \\
   & + & [ \;\texttt{goto}\;\textsl{next}\; ]  \\
   & + & [ \;\textsl{true}\texttt{:}\; ]  \\
   & + & [ \;\texttt{bipush}\;1\; ]  \\
   & + & [ \;\textsl{next}\texttt{:}\; ]  \\
   \end{array}
\]
Diese Gleichung ist in der Methode $\textsl{compile}()$ der Klasse \texttt{Equation} eins zu eins umgesetzt worden.

\subsubsection{Übersetzung von negierten Gleichungen}
Die Übersetzung einer negierten Gleichung der Form
\[ \textsl{lhs}\;\texttt{!=}\;\textsl{rhs} \]
verläuft analog zu der Übersetzung einer Gleichung, denn wir müssen hier nur den Befehl \texttt{if\_icmpeq}
durch den Befehl \texttt{if\_icmpne} ersetzen.  Daher lautet die Spezifikation
\[
   \begin{array}[t]{lcl}
   \textsl{compile}(\textsl{lhs}\;\texttt{!=}\;\textsl{rhs}) & = & 
         \textsl{lhs}.\textsl{compile}()  \\
   & + & \textsl{rhs}.\textsl{compile}()  \\
   & + & [ \;\texttt{if\_icmpne}\; \textsl{true} \; ]  \\
   & + & [ \;\texttt{bipush}\;0\; ]  \\
   & + & [ \;\texttt{goto}\;\textsl{next}\; ]  \\
   & + & [ \;\textsl{true}\texttt{:}\; ]  \\
   & + & [ \;\texttt{bipush}\;1\; ]  \\
   & + & [ \;\textsl{next}\texttt{:}\; ]  \\
   \end{array}
\]
Dies kann wieder eins zu eins umgesetzt werden.  Aus Platzgründen verzichten wir darauf, die Klasse 
\texttt{Inequation} zu präsentieren.

\subsubsection{Übersetzung von Ungleichungen}
The compilation of inequations of the form 
\\[0.2cm]
\hspace*{1.3cm}
$\textsl{lhs} \;\texttt{<=}\; \textsl{rhs}$, \quad 
$\textsl{lhs} \;\texttt{<}\; \textsl{rhs}$, \quad 
$\textsl{lhs} \;\texttt{>=}\; \textsl{rhs}$, \quad and \quad
$\textsl{lhs} \;\texttt{<}\; \textsl{rhs}$,
\\[0.2cm]
is essentially the same as the compilation of equations.  We only have to replace the assembler
command \texttt{if\_icmpeq} with either \texttt{if\_icmple}, \texttt{if\_icmplt},
\texttt{if\_icmpge}, or \texttt{if\_icmpgt}.

\subsubsection{Übersetzung von Konjunktionen}
Die Übersetzung einer Konjunktion der Form
\[ \textsl{lhs}\;\texttt{\&\&}\;\textsl{rhs} \]
kann wie folgt spezifiziert werden:
\[
   \begin{array}[t]{lcl}
   \textsl{compile}(\textsl{lhs}\;\texttt{\&\&}\;\textsl{rhs}) & = & 
         \textsl{lhs}.\textsl{compile}()  \\
   & + & \textsl{rhs}.\textsl{compile}()  \\
   & + & [ \;\texttt{iand}\; ]  
\end{array}
\]
Abbildung \ref{fig:Expr:Conjunction.java} zeigt die Umsetzung dieser Gleichung.

\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.8cm,
                  xrightmargin  = 0.8cm,
                ]
    public class Conjunction extends BoolExpr {
        private BoolExpr mLhs;
        private BoolExpr mRhs;
    
        public Conjunction(BoolExpr lhs, BoolExpr rhs) {
            mLhs = lhs;
            mRhs = rhs;
        }
        public List<AssemblerCmd> compile(Map<String, Integer> symbolTable) {
            List<AssemblerCmd> result = mLhs.compile(symbolTable);
            result.addAll(mRhs.compile(symbolTable));
            AssemblerCmd iand = new IAND();
            result.add(iand);
            return result;
        }
        public Integer stackSize() {
            return Math.max(mLhs.stackSize(), mRhs.stackSize() + 1);
        }
    }
\end{Verbatim}
\vspace*{-0.3cm}
\caption{Die Klasse \texttt{Conjunction}.}
\label{fig:Expr:Conjunction.java}
\end{figure}

Die obige Umsetzung entspricht allerdings nicht dem, was in der Sprache \texttt{C}
tatsächlich passiert.  Dort wird die Auswertung eines Ausdrucks der Form 
\\[0.2cm]
\hspace*{1.3cm}
\textsl{lhs} \texttt{\&\&} \textsl{rhs}
\\[0.2cm]
abgebrochen, sobald das Ergebnis der Auswertung feststeht.  Liefert die Auswertung
von \textsl{lhs} als Ergebnis eine $0$, so wird der Ausdruck \textsl{rhs} nicht mehr
ausgewertet.  Falls dieser Ausdruck Seiteneffekte hat, ist das Ergebnis der Auswertung dann
also verschieden von unserer Auswertung.

Eine Disjunktion wird in analoger Weise auf den Assembler-Befehl \texttt{ior} zurück geführt.

\subsubsection{Übersetzung von Negationen}
Die Übersetzung einer Negation der Form $\texttt{!}\textsl{expr}$ kann nicht so geradlinig behandelt
werden wie die Übersetzung von Konjunktionen und Disjunktionen.  Das liegt daran, dass es einen
Assembler-Befehl \texttt{inot}, der den oben auf dem Stack liegenden Wert negiert, nicht gibt.
Aber es geht auch anders, denn weil wir die Wahrheitswerte durch 1 und 0 darstellen, können wir die
Negation arithmetisch wie folgt spezifizieren:
\[ \texttt{!}x = 1 - x. \]
Damit verläuft die Übersetzung einer Negation nach dem folgenden Schema:
\[
   \begin{array}[t]{lcl}
   \textsl{compile}(\texttt{!}\textsl{expr}) & = & 
         [\;\texttt{bipush}\;1\;]  \\
   & + & \textsl{expr}.\textsl{compile}()  \\
   & + & [\;\texttt{isub}\;]  
\end{array}
\]
Abbildung \ref{fig:Expr:Negation.java} zeigt die Umsetzung dieser Idee.

\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.8cm,
                  xrightmargin  = 0.8cm,
                ]
    public class Negation extends BoolExpr {
        private BoolExpr mExpr;
    
        public Negation(BoolExpr expr) {
            mExpr = expr;
        }
        public List<AssemblerCmd> compile(Map<String, Integer> symbolTable) {
            List<AssemblerCmd> result = new LinkedList<AssemblerCmd>();
            AssemblerCmd bipush1 = new BIPUSH(1);
            AssemblerCmd isub    = new ISUB();
            result.add(bipush1);
            result.addAll(mExpr.compile(symbolTable));
            result.add(isub);
            return result;
        }
        public Integer stackSize() {
            return mExpr.stackSize() + 1;
        }    
    }
\end{Verbatim}
\vspace*{-0.3cm}
\caption{Die Klasse \texttt{Negation}.}
\label{fig:Expr:Negation.java}
\end{figure}


\subsection{How to Compile a Statement}
Next, we show how statements are compiled.  First of all, we agree that the execution of a statement
must not change the size of the stack:  The size of stack before the execution of a statement must
be the same as the size of the stack after after the statement has been executed.
Of course, during the execution of the statement the stack may well
grow.  But once the execution of the statement has finished, the stack has to be cleaned from all
intermediate values that have been put on the stack during the execution of the statement.


\subsubsection{Übersetzung von Zuweisungen}
Wir untersuchen als erstes, wie eine Zuweisung der Form
\[ x \;\texttt{=}\; \textsl{expr} \]
übersetzt werden kann.  Die Grundidee besteht darin, zunächst den Ausdruck \textsl{expr}
auszuwerten.  Als Folge dieser Auswertung wird dann ein Wert auf dem Stack zurück bleiben, der das
Ergebnis dieser Auswertung ist.  Diesen Wert können wir mit dem Befehl \texttt{istore} unter der
Variable $x$ abspeichern.  Folglich kann die Übersetzung einer Zuweisung wie folgt spezifiziert werden:
\[
   \begin{array}[t]{lcl}
   \textsl{compile}(x \texttt{=} \textsl{expr}) & = & 
         \textsl{expr}.\textsl{compile}()  \\
   & + & [\;\texttt{istore}\;x\;]  
\end{array}
\]
Die Idee wird in der in Abbildung \ref{fig:Statement:Assign.java} gezeigten Klasse
\texttt{Assign} umgesetzt.

\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.8cm,
                  xrightmargin  = 0.8cm,
                ]
    public class Assign extends Statement {
        private String mVar;
        private Expr   mExpr;
    
        public Assign(String var, Expr expr) {
            mVar  = var;
            mExpr = expr;
        }
        public List<AssemblerCmd> compile(Map<String, Integer> symbolTable) {
            List<AssemblerCmd> result   = mExpr.compile(symbolTable);
            AssemblerCmd       storeCmd = new ISTORE(symbolTable.get(mVar));
            result.add(storeCmd);
            return result;
        }
        public Integer stackSize() {
            return mExpr.stackSize();
        }    
    }
\end{Verbatim}
\vspace*{-0.3cm}
\caption{Die Klasse \texttt{Assign}.}
\label{fig:Statement:Assign.java}
\end{figure}

\subsubsection{Übersetzung von Ausdrücken als Befehlen}
Die Übersetzung eines Ausdrucks, der als Befehl verwendet wird, birgt eine Tücke:
Die Übersetzung des Ausdrucks selber hinterlässt auf dem Stack einen Wert.  Dieser muss aber bei
Beendigung des Befehls vom Stack entfernt werden!  Daher müssen wir den Befehl \texttt{pop} an das
Ende der Liste der Assembler-Befehle anfügen, die bei der Übersetzung des Ausdrucks erzeugt werden.
Die Übersetzung eines  Befehls vom Typ \texttt{ExprStatement} wird also
wie folgt spezifiziert:
\[
   \begin{array}[t]{lcl}
   \textsl{compile}(\textsl{expr}\texttt{;}) & = & 
         \textsl{expr}.\textsl{compile}()  \\
   & + & [\;\texttt{pop}\;]  
\end{array}
\]
Abbildung \ref{fig:Statement:ExprStatement.java} zeigt die Klasse \texttt{ExprStatement}, in der
diese Überlegung umgesetzt wird.

\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.8cm,
                  xrightmargin  = 0.8cm,
                ]
    public class ExprStatement extends Statement {
        private Expr mExpr;
    
        public ExprStatement(Expr expr) {
            mExpr = expr;
        }
        public List<AssemblerCmd> compile(Map<String, Integer> symbolTable) {
            List<AssemblerCmd> result = mExpr.compile(symbolTable);
            AssemblerCmd       popCmd = new POP();
            result.add(popCmd);
            return result;
        }    
        public Integer stackSize() {
            return mExpr.stackSize();
        }
    }
\end{Verbatim}
\vspace*{-0.3cm}
\caption{Die Klasse \texttt{ExprStatement}.}
\label{fig:Statement:ExprStatement.java}
\end{figure}

\subsubsection{Die Übersetzung von Verzweigungs-Befehlen}
Als nächstes überlegen wir, wie ein Verzweigungs-Befehl der Form
\[ \texttt{if}\; (\textsl{expr})\; \textsl{statement} \]
übersetzt werden kann.  Offenbar muss zunächst der Boole'sche Ausdruck \textsl{expr} übersetzt
werden.  Die Auswertung dieses Ausdrucks wird auf dem Stack entweder eine 1 oder eine 0
hinterlassen, je nachdem, ob die Bedingung des Tests wahr oder falsch wahr.  Mit dem Befehl
\texttt{ifeq} können wir überprüfen, welcher dieser beiden Fälle vorliegt.  
Das führt zu der folgenden Spezifikation:
\[
   \begin{array}[t]{lcl}
   \textsl{compile}\bigl(\texttt{if}\; (\textsl{expr})\;\textsl{statement}\bigr) & = & 
         \textsl{expr}.\textsl{compile}()  \\
   & + & [\;\texttt{ifeq}\;\textsl{else}\;] \\
   & + & \textsl{statement}.\textsl{compile}() \\
   & + & [\;\textsl{else}\texttt{:}\;]        
\end{array}
\]
Diese Spezifikation ist in der Abbildung \ref{fig:Statement:IfThen.java} umgesetzt worden.



\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.8cm,
                  xrightmargin  = 0.8cm,
                ]
    public class IfThen extends Statement {
        private BoolExpr  mBoolExpr;
        private Statement mStatement;
    
        public IfThen(BoolExpr boolExpr, Statement statement) {
            mBoolExpr = boolExpr;
            mStatement = statement;
        }
        public List<AssemblerCmd> compile(Map<String, Integer> symbolTable) {
            List<AssemblerCmd> result = mBoolExpr.compile(symbolTable);
            LABEL        elseLabel = new LABEL();
            AssemblerCmd ifeq      = new IFEQ(elseLabel.getLabel());
            result.add(ifeq);
            result.addAll(mStatement.compile(symbolTable));
            result.add(elseLabel);
            return result;
        }
        public Integer stackSize() {
            return Math.max(mBoolExpr.stackSize(), mStatement.stackSize());
        }
    }
\end{Verbatim}
\vspace*{-0.3cm}
\caption{Die Klasse \texttt{IfThen.java}}
\label{fig:Statement:IfThen.java}
\end{figure}

\vspace*{0.1cm}

Die Übersetzung eines Verzweigungs-Befehls der Form
\[ \texttt{if}\; (\textsl{expr})\; \textsl{thenStmnt} \;\texttt{else}\; \textsl{elseStmnt} \]
erfolgt in analoger Art und Weise.  Diesmal lautet die Spezifikation:
\[
   \begin{array}[t]{lcl}
   \textsl{compile}\bigl(\texttt{if}\; (\textsl{expr})\;\textsl{thenStmnt}\;\texttt{else}\;\textsl{elseStmnt}\bigr) & = & 
         \textsl{expr}.\textsl{compile}()  \\
   & + & [\;\texttt{ifeq}\;\textsl{else}\;] \\
   & + & \textsl{thenStmnt}.\textsl{compile}() \\
   & + & [\;\texttt{goto}\;\textsl{next}\;]    \\    
   & + & [\;\textsl{else}\texttt{:}\;]         \\
   & + & \textsl{elseStmnt}.\textsl{compile}()\;]    \\    
   & + & [\;\textsl{next}\texttt{:}\;]         
\end{array}
\]
Diese Spezifikation ist in der Abbildung \ref{fig:Statement:IfThenElse.java} umgesetzt worden.

\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.0cm,
                  xrightmargin  = 0.0cm,
                ]
    public class IfThenElse extends Statement {
        private BoolExpr  mExpr;
        private Statement mThen;
        private Statement mElse;
    
        public IfThenElse(BoolExpr expr, Statement thenStmnt, Statement elseStmnt) {
            mExpr = expr;
            mThen = thenStmnt;
            mElse = elseStmnt;
        }
        public List<AssemblerCmd> compile(Map<String, Integer> symbolTable) {
            List<AssemblerCmd> result = mExpr.compile(symbolTable);
            LABEL        elseLabel = new LABEL();
            LABEL        nextLabel = new LABEL();
            AssemblerCmd ifeq      = new IFEQ(elseLabel.getLabel());
            AssemblerCmd gotoNext  = new GOTO(nextLabel.getLabel());
            result.add(ifeq);
            result.addAll(mThen.compile(symbolTable));
            result.add(gotoNext);
            result.add(elseLabel);
            result.addAll(mElse.compile(symbolTable));
            result.add(nextLabel);
            return result;
        }
        public Integer stackSize() {
            return Math.max(mExpr.stackSize(), Math.max(mThen.stackSize(), mElse.stackSize()));
        }
    }
\end{Verbatim}
\vspace*{-0.3cm}
\caption{Die Klasse \texttt{IfThenElse}.}
\label{fig:Statement:IfThenElse.java}
\end{figure}

\subsubsection{Die Übersetzung einer Schleife}
Die Übersetzung einer \texttt{while}-Schleife der Form
\[ \texttt{while}\;(\textsl{cond})\;\textsl{statement} \]
orientiert sich an der folgenden Spezifikation:
\[
   \begin{array}[t]{lcl}
   \textsl{compile}\bigl(\texttt{while}\; (\textsl{cond})\;\textsl{stmnt}\bigr) & = & 
         [\;\textsl{loop}\texttt{:}\;]            \\
   & + & \textsl{cond}.\textsl{compile}()         \\
   & + & [\;\texttt{ifeq}\;\textsl{next}\;] \\
   & + & \textsl{stmnt}.\textsl{compile}()    \\    
   & + & [\;\texttt{goto}\;\textsl{loop}\;]    \\    
   & + & [\;\textsl{next}\texttt{:}\;]         
\end{array}
\]
Die Umsetzung dieser Spezifikation sehen Sie in Abbildung \ref{fig:Statement:While.java}.
 \begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.8cm,
                  xrightmargin  = 0.8cm,
                ]
    public class While extends Statement {
        private BoolExpr  mCondition;
        private Statement mStatement;
    
        public While(BoolExpr condition, Statement statement) {
            mCondition = condition;
            mStatement = statement;
        }
        public List<AssemblerCmd> compile(Map<String, Integer> symbolTable) {
            List<AssemblerCmd> result = new LinkedList<AssemblerCmd>();
            LABEL        loopLabel = new LABEL();
            LABEL        nextLabel = new LABEL();
            AssemblerCmd ifeq      = new IFEQ(nextLabel.getLabel());
            AssemblerCmd gotoLoop  = new GOTO(loopLabel.getLabel());
            result.add(loopLabel);
            result.addAll(mCondition.compile(symbolTable));
            result.add(ifeq);
            result.addAll(mStatement.compile(symbolTable));
            result.add(gotoLoop);
            result.add(nextLabel);
            return result;
        }
        public Integer stackSize() {
            return Math.max(mCondition.stackSize(), mStatement.stackSize());
        }
    }
\end{Verbatim}
\vspace*{-0.3cm}
\caption{Die Klasse \texttt{While}.}
\label{fig:Statement:While.java}
\end{figure}

\subsubsection{Übersetzen einer Liste von Befehlen}
Eine in geschweiften Klammern eingeschlossene Liste von Befehlen der Form
\[ \{ \textsl{stmnt}_1\texttt{;}\; \cdots\; \textsl{stmnt}_n\texttt{;} \} \]
wird dadurch übersetzt, dass die Listen, die bei der Übersetzung der einzelnen Befehle
$\textsl{stmnt}_i$ entstehen, aneinander gehängt werden:
\[
   \begin{array}[t]{lcl}
   \textsl{compile}\bigl(\texttt{\{} \textsl{stmnt}_1\texttt{;}\; \cdots\; \textsl{stmnt}_n\texttt{;} \texttt{\}}\bigr) & = & 
         \textsl{compile}(\textsl{stmnt}_1) + \cdots + \textsl{compile}(\textsl{stmnt}_n).
   \end{array}
\]
Diese Idee ist in der Klasse \texttt{Block} realisiert worden. Abbildung
\ref{fig:Statement:Block.java} zeigt diese Klasse.

\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.8cm,
                  xrightmargin  = 0.8cm,
                ]
    public class Block extends Statement {
        private List<Statement> mStatementList;
    
        public Block(List<Statement> statementList) {
            mStatementList = statementList;
        }
        public List<AssemblerCmd> compile(Map<String, Integer> symbolTable) {
            List<AssemblerCmd> result = new LinkedList<AssemblerCmd>();
            for (Statement stmnt: mStatementList) {
                result.addAll(stmnt.compile(symbolTable));
            }
            return result;
        }
        public Integer stackSize() {
            Integer biggest = 0;
            for (Statement stmnt: mStatementList) {
                biggest = Math.max(biggest, stmnt.stackSize());
            }
            return biggest;
        }
    }
\end{Verbatim}
\vspace*{-0.3cm}
\caption{Die Klasse \texttt{Block}.}
\label{fig:Statement:Block.java}
\end{figure}

\subsection{Zusammenspiel der Komponenten}
Nachdem wir jetzt gesehen haben, wie die einzelnen Teile eines Programms in Listen von
Assembler-Befehlen übersetzt werden können, müssen wir noch zeigen, wie die einzelnen Komponenten
unseres Programms zusammen spielen.  Dazu sind noch zwei Klassen zu diskutieren:
\begin{enumerate}
\item Die Klasse \texttt{Function} repräsentiert die Definition einer Funktion.
\item Die Klasse \texttt{Program}  repräsentiert das vollständige Programm.
\end{enumerate}
Wir beginnen mit der Diskussion der Klasse \texttt{Function}.  Abbildung
\ref{fig:Compiler:Function.java} zeigt die Klasse \texttt{Function}, allerdings ohne die
Implementierung der Methode $\textsl{compile}()$, die wir aus Platzgründen in die Abbildung
\ref{fig:Compiler:Function.compile} ausgelagert haben.

\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.3cm,
                  xrightmargin  = 0.3cm,
                ]
    public class Function {
        private String            mName;
        private List<String>      mParameterList;
        private List<Declaration> mDeclarations;
        private List<Statement>   mBody;
        
        private Integer           mLocals; // number of local variables
    
        public Function(String            name, 
                        List<String>      parameterList, 
                        List<Declaration> declarations, 
                        List<Statement>   body) 
        {
            mName          = name;
            mParameterList = parameterList;
            mDeclarations  = declarations;
            mBody          = body;
            mLocals        = mParameterList.size() + mDeclarations.size();
        }
        public List<AssemblerCmd> compile() { ... }
        public Integer stackSize() { ... }
    }
\end{Verbatim}
\vspace*{-0.3cm}
\caption{Die Klasse \texttt{Function}.}
\label{fig:Compiler:Function.java}
\end{figure}


Die Klasse \texttt{Function} enthält vier Member-Variablen:
\begin{enumerate}
\item \texttt{mName} gibt den Namen der Funktion an.
\item \texttt{mParameterList} ist die Liste der Parameter, 
      mit der die Funktion aufgerufen wird.
\item \texttt{mDeclarations} ist die Liste der Variablen-Deklarationen.
\item \texttt{mBody} ist die Liste von Befehlen, die im Rumpf der Funktion
      ausgeführt werden.
\end{enumerate}

\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.8cm,
                  xrightmargin  = 0.8cm,
                ]
    public List<AssemblerCmd> compile() {
        Map<String, Integer> symbolTable = new TreeMap();
        Integer count = 0;
        for (String var: mParameterList) {
            symbolTable.put(var, count);
            ++count;
        }
        for (Declaration decl: mDeclarations) {
            symbolTable.put(decl.getVar(), count);
            ++count;
        }
        Integer stackSize = 0;
        for (Statement stmnt: mBody) {
            stackSize = Math.max(stackSize, stmnt.stackSize());
        }
        List<AssemblerCmd> result = new LinkedList<AssemblerCmd>();
        AssemblerCmd nl = new NEWLINE();
        result.add(nl);
        if (mName.equals("main")) {
            AssemblerCmd main        = new MAIN();
            AssemblerCmd limitLocals = new LIMIT("locals", mLocals);
            AssemblerCmd limitStack  = new LIMIT("stack", stackSize);
            result.add(main);
            result.add(limitLocals);
            result.add(limitStack);
            for (Statement stmnt: mBody) {
                result.addAll(stmnt.compile(symbolTable));
            }
            AssemblerCmd myReturn = new RETURN();
            AssemblerCmd endMain  = new END_METHOD();
            result.add(myReturn);
            result.add(endMain);
        } else {
            AssemblerCmd method      = new METHOD(mName, mParameterList.size());
            AssemblerCmd limitLocals = new LIMIT("locals", mLocals);
            AssemblerCmd limitStack  = new LIMIT("stack", stackSize);
            result.add(method);
            result.add(limitLocals);
            result.add(limitStack);
            for (Statement stmnt: mBody) {
                result.addAll(stmnt.compile(symbolTable));
            }
            AssemblerCmd endMethod = new END_METHOD();
            result.add(endMethod);
        }
        return result;
    }
\end{Verbatim}
\vspace*{-0.3cm}
\caption{Die Methode $\textsl{compile}()$.}
\label{fig:Compiler:Function.compile}
\end{figure}

\vspace*{\fill}
\pagebreak

\vspace*{\fill}
\pagebreak

Die eigentliche Arbeit der Klasse \texttt{Funktion} wird in der Methode $\textsl{compile}()$, die in Abbildung
\ref{fig:Compiler:Function.compile} gezeigt ist, geleistet.  Es sind zwei Fälle zu unterscheiden:
\begin{enumerate}
\item Falls die zu übersetzende Funktion den Namen \squoted{main} hat, so hat der erzeugte
      Code die folgende Form:

      \begin{Verbatim}[ frame         = lines, 
                        framesep      = 0.3cm, 
                        labelposition = bottomline,
                        numbers       = left,
                        numbersep     = -0.2cm,
                        xleftmargin   = 0.8cm,
                        xrightmargin  = 0.8cm,
                        commandchars  = \\\{\},
                        codes={\catcode`$=3\catcode`^=7\catcode`_=8}
                      ]
            .method public static main([Ljava/lang/String;)V
            .limit locals \(l\) 
            .limit stack \(s\)
               \(s_1\)
               \(\vdots\)
               \(s_n\)
               return
            .end-main
       \end{Verbatim}
       % \$

       Hier bezeichnet $l$ die Anzahl der in der Funktion \texttt{main} verwendeten lokalen Variablen,
       $s$ ist die maximale Höhe des Stacks
       und $s_1$, $\cdots$, $s_n$ bezeichnen die einzelnen Assemblerbefehle, die bei der Übersetzung
       des Rumpfes der Funktion erzeugt werden.

\item Andernfalls hat der erzeugte Code die folgende Form:

      \begin{Verbatim}[ frame         = lines, 
                        framesep      = 0.3cm, 
                        labelposition = bottomline,
                        numbers       = left,
                        numbersep     = -0.2cm,
                        xleftmargin   = 0.8cm,
                        xrightmargin  = 0.8cm,
                        commandchars  = \\\{\},
                        codes={\catcode`$=3\catcode`^=7\catcode`_=8}
                      ]
            .method public static \(f\)(I\(\cdots\)I)I
            .limit locals \(l\) 
            .limit stack \(s\)
               \(s_1\)
               \(\vdots\)
               \(s_n\)
            .end-method
       \end{Verbatim}
       % $
       
       Hier bezeichnet $f$ den Namen der Funktion,  $l$ ist die Anzahl der in der Funktion verwendeten lokalen Variablen
       und $s$ ist die maximale Höhe des Stacks.
       Weiter sind $s_1$, $\cdots$, $s_n$ die Assemblerbefehle des Rumpfes der Funktion.
\end{enumerate}
Abbildung \ref{fig:Compiler:Function.stackSize} zeigt die Implementierung der Funktion
\texttt{stackSize}. Da die einzelnen Befehle nichts auf dem Stack zurück lassen dürfen, ergibt sich
die Höhe des Stacks, der zur Ausführung aller Befehle benötigt wird, als das Maximum der Höhen der
einzelnen Befehle.


\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  firstnumber   = 1,
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.8cm,
                  xrightmargin  = 0.8cm,
                ]
    public Integer stackSize() {
        Integer biggest = 0;
        for (Statement stmnt: mBody) {
            biggest = Math.max(biggest, stmnt.stackSize());
        }
        return biggest;
    }    
\end{Verbatim}
\vspace*{-0.3cm}
\caption{Computing the size of the stack}
\label{fig:Compiler:Function.stackSize}
\end{figure}


\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.5cm,
                  xrightmargin  = 0.5cm,
                ]    
    public class Program {
        private List<Function> mFunctionList;
    
        public Program(List<Function> functionList) {
            mFunctionList = functionList;
        }
        public List<AssemblerCmd> compile() {
            List<AssemblerCmd> fctList = new LinkedList<AssemblerCmd>();
            int indexMain = mFunctionList.size() - 1;
            Function main = mFunctionList.get(indexMain);
            fctList.addAll(main.compile());
            for (int i = 0; i < indexMain; ++i) {
                Function f = mFunctionList.get(i);
                fctList.addAll(f.compile());
            }
            return fctList;
        }
    }
\end{Verbatim}
\vspace*{-0.3cm}
\caption{Die Klasse \texttt{Program}.}
\label{fig:Program.java}
\end{figure}
 
\noindent
Zum Abschluss diskutieren wir die Klasse \texttt{Program}, die in Abbildung
\ref{fig:Program.java} gezeigt wird.  Diese Klasse verwaltet in der Member-Variablen
\texttt{mFunctionList} die Liste aller zu übersetzenden Funktionen.  

Bei der Übersetzung der Funktionen ist darauf zu achten, dass zuerst die Funktion $\textsl{main}()$
übersetzt wird, denn diese muss am Anfang der erzeugten Assembler-Datei stehen.  In der
\texttt{C}-Datei ist die Funktion $\textsl{main}()$ aber die letzte Funktion, denn in der Sprache
\texttt{C} müssen alle Funktionen vor ihrer Verwendung deklariert worden sein.

Wie übersetzen in Zeile 11 als erstes die Funktion $\textsl{main}()$.  Anschließend werden in der
Schleife, die sich von Zeile 12 bis 15 erstreckt, die restlichen Funktionen übersetzt.
Der erzeugte Code befindet sich dann in der Liste \texttt{fctList}, die als Ergebnis zurück gegeben wird.  


Übersetzen wir die in Abbildung
\ref{fig:sum.c} gezeigte Funktion zur Berechnung der Summe $\sum_{i=1}^n i$ mit dem Compiler, so
erhalten wir die in Abbildungen \ref{fig:sum.jas} gezeigte Assembler-Datei, bei der wir zur Vereinfachung den
Code zur Initialisierung, der immer gleich ist, weggelassen haben.
Vergleichen wir dieses Programm mit dem in Abbildung \ref{fig:sum.jas} gezeigten
Assembler-Programm, das wir von Hand geschrieben haben, so fällt auf, dass das vom Compiler erzeugte Programm 
deutlich länger ist.  Es wäre nun Aufgabe eines Code-Optimierers, den erzeugten Code zu verkürzen
und dadurch zu optimieren.  Eine Diskussion von Techniken zur Code-Optimierung geht allerdings über
den Rahmen der Vorlesung heraus. 

\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                 framesep      = 0.3cm, 
                 firstnumber   = 1,
                 numbers       = left,
                 numbersep     = -0.2cm,
                 xleftmargin   = 0.8cm,
                 xrightmargin  = 0.8cm,
               ]
    .method public static main([Ljava/lang/String;)V
    .limit locals 1
    .limit stack  2
            ldc 6
            ldc 6
            imul
            istore 0
            getstatic java/lang/System/out Ljava/io/PrintStream;
            iload 0
            invokestatic MySum/sum(I)I
            invokevirtual java/io/PrintStream/println(I)V
            bipush 42
            pop
            return
    .end method
      
    .method public static sum(I)I
    .limit locals 2
    .limit stack  2
            ldc 0
            istore 1
        l3:
            iload 0
            ldc 0
            if_icmpne l1
            bipush 0
            goto l2
        l1:
            bipush 1
        l2:
            ifeq l4
            iload 1
            iload 0
            iadd
            istore 1
            iload 0
            ldc 1
            isub
            istore 0
            goto l3
        l4:
            iload 1
            ireturn
    .end method
\end{Verbatim}
\vspace*{-0.3cm}
\caption{Der von unserem Compiler erzeugte Code.}
\label{fig:sum.jas}
\end{figure}

\exerciseEng
The goal of this exercise is to extend the language supported by the compiler presented in this chapter.
\begin{enumerate}
\item[(a)] Extend the compiler so that \texttt{for}-loops are supported.  The syntax of these \texttt{for}-loops
           should be similar to the syntax of \texttt{for}-loops in the programming language \texttt{C}.
\item[(b)] Extend the compiler so that increment and decrement statements of the form
           \\[0.2cm]
           \hspace*{1.3cm}
           \texttt{++}\textsl{var}\texttt{;}  \quad and \quad
           \texttt{--}\textsl{var}\texttt{;}  
           \\[0.2cm]
           are supported.  As we only intend to use these statements in the update statement of a
           \texttt{for}-loop, there is no need to support these operators inside expressions. 
\end{enumerate}
In order to test your version of the compiler, rewrite the example integer-\texttt{C} program
presented in this chapter to use both a \texttt{for}-loop and the increment operator.  \eox


%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "formal-languages"
%%% End: 
